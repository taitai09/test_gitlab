<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--  
	2018.06.07	이원식	OPENPOP V2 최초작업
-->
<mapper namespace="omc.spop.dao.PredictiveFailureAnalysisDao">	
	<select id="cpuIncreaseUsageChartList_old_20190716" parameterType="cpuIncreaseUsage" resultType="cpuIncreaseUsage">
		/* PredictiveFailureAnalysisMapper.cpuIncreaseUsageChartList */
		WITH DB_PRIV AS
		(
			SELECT /*+ MATERIALIZE */
				UDP.DBID, DB.DB_NAME, I.INST_ID, I.INST_NM
			FROM USER_DB_PRIVILEGE UDP, USERS U, DATABASE DB, INSTANCE I
			WHERE UDP.USER_ID = U.USER_ID
			AND UDP.DBID = DB.DBID
			AND DB.DBID = I.DBID
			AND DB.USE_YN = 'Y'
			AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN UDP.PRIVILEGE_START_DAY AND UDP.PRIVILEGE_END_DAY
			AND U.USER_ID = #{user_id}
            AND DB.DB_OPERATE_TYPE_CD = (SELECT DEFAULT_PREF_VALUE 
                                          FROM SPOP_PREFERENCES 
                                         WHERE PREF_ID = '22001') 			
		), DB_PREF AS
		(
			SELECT /*+ MATERIALIZE */
				DBID, 
				BASELINE_DAY,
				LPAD(REGEXP_SUBSTR(BUSINESS_HOUR, '[^-]+', 1, 1), 2, '0')||'01' START_BUSINESS_HOUR,
				LPAD(REGEXP_SUBSTR(BUSINESS_HOUR, '[^-]+', 1, 2), 2, '0')||'00' END_BUSINESS_HOUR				
			FROM
			(
				SELECT A.DBID,
					MAX(CASE WHEN A.PREF_ID = 21001 THEN TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) END) AS BASELINE_DAY,
					MAX(CASE WHEN A.PREF_ID = 21002 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) END) AS BUSINESS_HOUR
				FROM
				(
					SELECT /*+ LEADING(DB) */
						DB.DBID, SP.PREF_ID, SP.DEFAULT_PREF_VALUE
					FROM
					(
						SELECT DISTINCT DBID FROM DB_PRIV
					) DB, SPOP_PREFERENCES SP
					WHERE PREF_ID IN (21001, 21002)
				) A,
				( SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
				    FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
				               , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
					          FROM DB_PREFERENCES B
					         WHERE PREF_ID IN (21001, 21002)
					       )
					 WHERE PREF_SEQ = MAX_PREF_SEQ         
				) B
				WHERE A.DBID = B.DBID(+)
				AND A.PREF_ID = B.PREF_ID(+)
				GROUP BY A.DBID
			)
		), BASELINE_DAY AS
		(
			SELECT A.DBID, MIN(DAY) START_DAY, MAX(DAY) END_DAY, COUNT(*) DAY_COUNT
			FROM
			(
				SELECT A.DAY, B.DBID, ROW_NUMBER() OVER(PARTITION BY B.DBID ORDER BY A.DAY DESC) RNUM
				FROM CALENDAR A, 
				(
					SELECT DISTINCT DBID FROM DB_PRIV
				) B
				WHERE A.DAY <![CDATA[ < ]]> TRUNC(TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD'))
			) A, DB_PREF B
			WHERE A.DBID = B.DBID
			AND A.RNUM <![CDATA[ <= ]]> B.BASELINE_DAY
			GROUP BY A.DBID
		), BASELINE_CPU AS
		(
			SELECT A.DBID, A.INSTANCE_NUMBER, ROUND(AVG(A.AVERAGE), 2) CPU_USAGE
			FROM ODS_HIST_SYSMETRIC_SUMMARY A, BASELINE_DAY B, DB_PREF C
			WHERE A.DBID = B.DBID
			AND A.DBID = C.DBID
			AND A.BEGIN_TIME >= B.START_DAY 
			AND A.BEGIN_TIME <![CDATA[ < ]]> B.END_DAY+1
			AND A.METRIC_ID = '2057'
			<choose>
				<when test="(searchKey != null and (searchKey eq '01'.toString()))"> <!-- 주간 -->
					AND TO_CHAR(A.BEGIN_TIME, 'HH24MI') >= C.START_BUSINESS_HOUR
					AND TO_CHAR(A.BEGIN_TIME, 'HH24MI') <![CDATA[ <= ]]> C.END_BUSINESS_HOUR
				</when>
				<when test="(searchKey != null and (searchKey eq '02'.toString()))"> <!-- 야간 -->
					AND (TO_CHAR(A.BEGIN_TIME, 'HH24MI') BETWEEN '0000' AND C.START_BUSINESS_HOUR
					OR TO_CHAR(A.BEGIN_TIME, 'HH24MI') BETWEEN C.END_BUSINESS_HOUR AND '2359')
				</when>	
			</choose>
			GROUP BY A.DBID, A.INSTANCE_NUMBER
		), CURRENT_CPU AS
		(
			SELECT A.DBID, A.INSTANCE_NUMBER, ROUND(AVG(AVERAGE), 2) CPU_USAGE
			FROM ODS_HIST_SYSMETRIC_SUMMARY A, BASELINE_DAY B, DB_PREF C
			WHERE A.DBID = B.DBID
			AND A.DBID = C.DBID
			AND A.BEGIN_TIME >= B.END_DAY+1
			AND A.BEGIN_TIME <![CDATA[ < ]]> TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD')+1
			AND A.METRIC_ID = '2057'
			<choose>
				<when test="(searchKey != null and (searchKey eq '01'.toString()))"> <!-- 주간 -->
					AND TO_CHAR(A.BEGIN_TIME, 'HH24MI') >= C.START_BUSINESS_HOUR
					AND TO_CHAR(A.BEGIN_TIME, 'HH24MI') <![CDATA[ <= ]]> C.END_BUSINESS_HOUR
				</when>
				<when test="(searchKey != null and (searchKey eq '02'.toString()))"> <!-- 야간 -->
					AND (TO_CHAR(A.BEGIN_TIME, 'HH24MI') BETWEEN '0000' AND C.START_BUSINESS_HOUR
					OR TO_CHAR(A.BEGIN_TIME, 'HH24MI') BETWEEN C.END_BUSINESS_HOUR AND '2359')
				</when>	
			</choose>
			GROUP BY A.DBID, A.INSTANCE_NUMBER
		)
		SELECT A.DBID, DB.DB_NAME, DB.INST_ID, DB.INST_NM, A.CPU_USAGE AS BASELINE_CPU_USAGE,
			B.CPU_USAGE AS CURRENT_CPU_USAGE, ROUND(B.CPU_USAGE/A.CPU_USAGE, 2) AS CPU_INCREASE_RATIO
		FROM BASELINE_CPU A, CURRENT_CPU B, DB_PRIV DB
		WHERE A.DBID = B.DBID
		AND A.INSTANCE_NUMBER = B.INSTANCE_NUMBER
		AND A.DBID = DB.DBID
		AND A.INSTANCE_NUMBER = DB.INST_ID
		AND ROUND(B.CPU_USAGE/A.CPU_USAGE, 2) >= ${selectValue}
		ORDER BY ROUND(B.CPU_USAGE/A.CPU_USAGE, 2) DESC
	</select>

	<select id="cpuIncreaseUsageChartList" parameterType="cpuIncreaseUsage" resultType="cpuIncreaseUsage">
		/* PredictiveFailureAnalysisMapper.cpuIncreaseUsageChartList */
		WITH DB_PRIV AS
		(
			SELECT /*+ MATERIALIZE */
				UDP.DBID, DB.DB_NAME, I.INST_ID, I.INST_NM
			FROM USER_DB_PRIVILEGE UDP, USERS U, DATABASE DB, INSTANCE I
			WHERE UDP.USER_ID = U.USER_ID
			AND UDP.DBID = DB.DBID
			AND DB.DBID = I.DBID
			AND DB.USE_YN = 'Y'
			AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN UDP.PRIVILEGE_START_DAY AND UDP.PRIVILEGE_END_DAY
			AND U.USER_ID = #{user_id}
            AND DB.DB_OPERATE_TYPE_CD = (SELECT DEFAULT_PREF_VALUE 
                                          FROM SPOP_PREFERENCES 
                                         WHERE PREF_ID = '22001') 			
		), DB_PREF AS
		(
			SELECT /*+ MATERIALIZE */
				DBID, 
				BASELINE_DAY,
				LPAD(REGEXP_SUBSTR(BUSINESS_HOUR, '[^-]+', 1, 1), 2, '0')||'0000' START_BUSINESS_HOUR,
				LPAD(TO_NUMBER(REGEXP_SUBSTR(BUSINESS_HOUR, '[^-]+', 1, 2)) - 1, 2, '0')||'5959' END_BUSINESS_HOUR
			FROM
			(
				SELECT A.DBID,
					MAX(CASE WHEN A.PREF_ID = 21001 THEN TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) END) AS BASELINE_DAY,
					MAX(CASE WHEN A.PREF_ID = 21002 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) END) AS BUSINESS_HOUR
				FROM
				(
					SELECT /*+ LEADING(DB) */
						DB.DBID, SP.PREF_ID, SP.DEFAULT_PREF_VALUE
					FROM
					(
						SELECT DISTINCT DBID FROM DB_PRIV
					) DB, SPOP_PREFERENCES SP
					WHERE PREF_ID IN (21001, 21002)
				) A,
				( SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
				    FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
				               , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
					          FROM DB_PREFERENCES B
					         WHERE PREF_ID IN (21001, 21002)
					       )
					 WHERE PREF_SEQ = MAX_PREF_SEQ        
				) B
				WHERE A.DBID = B.DBID(+)
				AND A.PREF_ID = B.PREF_ID(+)
				GROUP BY A.DBID
			)
		), BASELINE_DAY AS
		(
			SELECT A.DBID, MIN(DAY) START_DAY, MAX(DAY) END_DAY, COUNT(*) DAY_COUNT
			FROM
			(
				SELECT A.DAY, B.DBID, ROW_NUMBER() OVER(PARTITION BY B.DBID ORDER BY A.DAY DESC) RNUM
				FROM CALENDAR A, 
				(
					SELECT DISTINCT DBID FROM DB_PRIV
				) B
				WHERE A.DAY <![CDATA[ < ]]> TRUNC(TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD'))
			) A, DB_PREF B
			WHERE A.DBID = B.DBID
			AND A.RNUM <![CDATA[ <= ]]> B.BASELINE_DAY
			GROUP BY A.DBID
		), BASELINE_CPU AS
		(
			SELECT A.DBID, A.INSTANCE_NUMBER, ROUND(AVG(A.AVERAGE), 2) CPU_USAGE
			FROM ODS_HIST_SYSMETRIC_SUMMARY A, BASELINE_DAY B, DB_PREF C
			WHERE A.DBID = B.DBID
			AND A.DBID = C.DBID
			AND A.BEGIN_TIME >= B.START_DAY 
			AND A.BEGIN_TIME <![CDATA[ < ]]> B.END_DAY+1
			AND A.METRIC_ID = '2057'
			<choose>
				<when test="(searchKey != null and (searchKey eq '01'.toString()))"> <!-- 주간 -->
					AND TO_CHAR(A.BEGIN_TIME, 'HH24MISS') >= C.START_BUSINESS_HOUR
					AND TO_CHAR(A.BEGIN_TIME, 'HH24MISS') <![CDATA[ <= ]]> C.END_BUSINESS_HOUR
				</when>
				<when test="(searchKey != null and (searchKey eq '02'.toString()))"> <!-- 야간 -->
					AND ((TO_CHAR(A.BEGIN_TIME, 'HH24MISS') >= '000000' AND TO_CHAR(A.BEGIN_TIME, 'HH24MISS') <![CDATA[ < ]]> C.START_BUSINESS_HOUR)
					OR (TO_CHAR(A.BEGIN_TIME, 'HH24MISS') > C.END_BUSINESS_HOUR AND TO_CHAR(A.BEGIN_TIME, 'HH24MISS') <![CDATA[ <= ]]> '235959'))
				</when>	
			</choose>
			GROUP BY A.DBID, A.INSTANCE_NUMBER
		), CURRENT_CPU AS
		(
			SELECT A.DBID, A.INSTANCE_NUMBER, ROUND(AVG(AVERAGE), 2) CPU_USAGE
			FROM ODS_HIST_SYSMETRIC_SUMMARY A, BASELINE_DAY B, DB_PREF C
			WHERE A.DBID = B.DBID
			AND A.DBID = C.DBID
			AND A.BEGIN_TIME >= B.END_DAY+1
			AND A.BEGIN_TIME <![CDATA[ < ]]> TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD')+1
			AND A.METRIC_ID = '2057'
			<choose>
				<when test="(searchKey != null and (searchKey eq '01'.toString()))"> <!-- 주간 -->
					AND TO_CHAR(A.BEGIN_TIME, 'HH24MISS') >= C.START_BUSINESS_HOUR
					AND TO_CHAR(A.BEGIN_TIME, 'HH24MISS') <![CDATA[ <= ]]> C.END_BUSINESS_HOUR
				</when>
				<when test="(searchKey != null and (searchKey eq '02'.toString()))"> <!-- 야간 -->
					AND ((TO_CHAR(A.BEGIN_TIME, 'HH24MISS') >= '000000' AND TO_CHAR(A.BEGIN_TIME, 'HH24MISS') <![CDATA[ < ]]> C.START_BUSINESS_HOUR)
					OR (TO_CHAR(A.BEGIN_TIME, 'HH24MISS') > C.END_BUSINESS_HOUR AND TO_CHAR(A.BEGIN_TIME, 'HH24MISS') <![CDATA[ <= ]]> '235959'))
				</when>	
			</choose>
			GROUP BY A.DBID, A.INSTANCE_NUMBER
		)
		SELECT A.DBID, DB.DB_NAME, DB.INST_ID, DB.INST_NM, A.CPU_USAGE AS BASELINE_CPU_USAGE,
			B.CPU_USAGE AS CURRENT_CPU_USAGE, ROUND(B.CPU_USAGE/A.CPU_USAGE, 2) AS CPU_INCREASE_RATIO
		FROM BASELINE_CPU A, CURRENT_CPU B, DB_PRIV DB
		WHERE A.DBID = B.DBID
		AND A.INSTANCE_NUMBER = B.INSTANCE_NUMBER
		AND A.DBID = DB.DBID
		AND A.INSTANCE_NUMBER = DB.INST_ID
		AND ROUND(B.CPU_USAGE/A.CPU_USAGE, 2) >= ${selectValue}
		ORDER BY ROUND(B.CPU_USAGE/A.CPU_USAGE, 2) DESC
	</select>
	
	<select id="cpuUsageChartList" parameterType="cpuIncreaseUsage" resultType="cpuIncreaseUsage">
		/* PredictiveFailureAnalysisMapper.cpuUsageChartList */
		WITH BASELINE_DAY AS
		(
			SELECT MIN(DAY) START_DAY, MAX(DAY) END_DAY, COUNT(*) DAY_COUNT
			FROM
			(
				SELECT * 
				FROM CALENDAR
				WHERE DAY <![CDATA[ < ]]> TRUNC(TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD'))
				ORDER BY DAY DESC
			)
			WHERE ROWNUM <![CDATA[ <= ]]> 7
		), SNAPSHOT_TIME AS
		(
			SELECT A.SNAP_ID, 
			TRUNC(A.BEGIN_INTERVAL_TIME, 'mi') -
			(
				CASE 
				WHEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
				ELSE MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) 
				END
			) / (24 * 60) AS BEGIN_INTERVAL_TIME,
			TRUNC(A.END_INTERVAL_TIME, 'mi') -
			(
				CASE 
				WHEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
				ELSE MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) 
				END
			) / (24 * 60) AS END_INTERVAL_TIME
			FROM ODS_HIST_SNAPSHOT A, BASELINE_DAY B
			WHERE A.BEGIN_INTERVAL_TIME >= B.START_DAY 
			AND A.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+2
			AND A.DBID = #{dbid}
			AND A.INSTANCE_NUMBER = #{inst_id}
			ORDER BY A.SNAP_ID
		), BASELINE_CPU AS
		(
			SELECT TO_CHAR(C.BEGIN_INTERVAL_TIME, 'HH24:MI') SNAP_TIME, ROUND(AVG(AVERAGE), 2) CPU_USAGE
			FROM ODS_HIST_SYSMETRIC_SUMMARY A, BASELINE_DAY B, SNAPSHOT_TIME C
			WHERE A.BEGIN_TIME >= B.START_DAY 
			AND A.BEGIN_TIME <![CDATA[ < ]]> B.END_DAY+1
			AND A.SNAP_ID = C.SNAP_ID
			AND A.METRIC_ID = '2057'
			AND A.DBID = #{dbid}
			AND A.INSTANCE_NUMBER = #{inst_id}
			GROUP BY TO_CHAR(C.BEGIN_INTERVAL_TIME, 'HH24:MI') 
			ORDER BY SNAP_TIME
		), CURRENT_CPU AS
		(
			SELECT TO_CHAR(C.BEGIN_INTERVAL_TIME, 'HH24:MI') SNAP_TIME, ROUND(AVG(AVERAGE), 2) CPU_USAGE
			FROM ODS_HIST_SYSMETRIC_SUMMARY A, BASELINE_DAY B, SNAPSHOT_TIME C
			WHERE A.BEGIN_TIME >= B.END_DAY+1
			AND A.BEGIN_TIME <![CDATA[ < ]]> TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD')+1
			AND A.SNAP_ID = C.SNAP_ID
			AND A.METRIC_ID = '2057'
			AND A.DBID = #{dbid}
			AND A.INSTANCE_NUMBER = #{inst_id}
			GROUP BY TO_CHAR(C.BEGIN_INTERVAL_TIME, 'HH24:MI') 
			ORDER BY SNAP_TIME
		)
		SELECT A.SNAP_TIME, A.CPU_USAGE AS BASELINE_CPU_USAGE, B.CPU_USAGE AS CURRENT_CPU_USAGE
		FROM BASELINE_CPU A, CURRENT_CPU B
		WHERE A.SNAP_TIME = B.SNAP_TIME	
	</select>
	
	<select id="userTimeChartList" parameterType="cpuIncreaseUsage" resultType="cpuIncreaseUsage">
		/* PredictiveFailureAnalysisMapper.userTimeChartList */
		WITH BASELINE_DAY AS
		(
			SELECT MIN(DAY) START_DAY, MAX(DAY) END_DAY, COUNT(*) DAY_COUNT
			FROM
			(
				SELECT * 
				FROM CALENDAR
				WHERE DAY <![CDATA[ < ]]> TRUNC(TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD'))
				ORDER BY DAY DESC
			)
			WHERE ROWNUM <![CDATA[ <= ]]> 7
		), SNAPSHOT_TIME AS
		(
			SELECT A.SNAP_ID, 
				A.STARTUP_TIME,
				TRUNC(A.BEGIN_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS BEGIN_INTERVAL_TIME,
				TRUNC(A.END_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS END_INTERVAL_TIME
			FROM ODS_HIST_SNAPSHOT A, BASELINE_DAY B
			WHERE A.BEGIN_INTERVAL_TIME >= B.START_DAY 
			AND A.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+2
			AND A.DBID = #{dbid}
			AND A.INSTANCE_NUMBER = #{inst_id}
			ORDER BY A.SNAP_ID
		), BASELINE_CPU AS
		(
			SELECT TO_CHAR(BEGIN_INTERVAL_TIME, 'HH24:MI') SNAP_TIME
				, ROUND(AVG(VAL1-BF_VAL1)/10000, 2) USER_TIME
			FROM
			(
				SELECT A.STAT_NAME
					, C.BEGIN_INTERVAL_TIME
					, A.VALUE VAL1
					, LAG(VALUE) OVER(PARTITION BY C.STARTUP_TIME, A.STAT_NAME, TO_CHAR(C.BEGIN_INTERVAL_TIME, 'YYYY/MM/DD') ORDER BY C.BEGIN_INTERVAL_TIME) BF_VAL1
				FROM ODS_HIST_OSSTAT A, BASELINE_DAY B, SNAPSHOT_TIME C
				WHERE C.BEGIN_INTERVAL_TIME >= B.START_DAY 
				AND C.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+1
				AND A.SNAP_ID = C.SNAP_ID
				AND A.STAT_NAME = 'USER_TIME'
				AND A.DBID = #{dbid}
				AND A.INSTANCE_NUMBER = #{inst_id}
				ORDER BY C.BEGIN_INTERVAL_TIME
			)
			GROUP BY TO_CHAR(BEGIN_INTERVAL_TIME, 'HH24:MI')
		), CURRENT_CPU AS
		(
			SELECT TO_CHAR(BEGIN_INTERVAL_TIME, 'HH24:MI') SNAP_TIME
				, ROUND((VAL1-BF_VAL1)/10000, 2) USER_TIME
			FROM
			(
				SELECT A.STAT_NAME
					, C.BEGIN_INTERVAL_TIME
					, A.VALUE VAL1
					, LAG(VALUE) OVER(PARTITION BY C.STARTUP_TIME, A.STAT_NAME ORDER BY C.BEGIN_INTERVAL_TIME) BF_VAL1
				FROM ODS_HIST_OSSTAT A, BASELINE_DAY B, SNAPSHOT_TIME C
				WHERE C.BEGIN_INTERVAL_TIME >= B.END_DAY+1
				AND C.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD')+1
				AND A.SNAP_ID = C.SNAP_ID
				AND A.STAT_NAME = 'USER_TIME' 
				AND A.DBID = #{dbid}
				AND A.INSTANCE_NUMBER = #{inst_id}
				ORDER BY C.BEGIN_INTERVAL_TIME
			)		
		)
		SELECT A.SNAP_TIME, A.USER_TIME AS BASELINE_USER_TIME, B.USER_TIME AS CURRENT_USER_TIME
		FROM BASELINE_CPU A, CURRENT_CPU B
		WHERE A.SNAP_TIME = B.SNAP_TIME
		AND A.USER_TIME IS NOT NULL
		AND B.USER_TIME IS NOT NULL	
	</select>
	
	<select id="sysTimeChartList" parameterType="cpuIncreaseUsage" resultType="cpuIncreaseUsage">
		/* PredictiveFailureAnalysisMapper.sysTimeChartList */
		WITH BASELINE_DAY AS
		(
			SELECT MIN(DAY) START_DAY, MAX(DAY) END_DAY, COUNT(*) DAY_COUNT
			FROM
			(
				SELECT * 
				FROM CALENDAR
				WHERE DAY <![CDATA[ < ]]> TRUNC(TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD'))
				ORDER BY DAY DESC
			)
			WHERE ROWNUM <![CDATA[ <= ]]> 7
		), SNAPSHOT_TIME AS
		(
			SELECT A.SNAP_ID, 
				A.STARTUP_TIME,
				TRUNC(A.BEGIN_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS BEGIN_INTERVAL_TIME,
				TRUNC(A.END_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS END_INTERVAL_TIME
			FROM ODS_HIST_SNAPSHOT A, BASELINE_DAY B
			WHERE A.BEGIN_INTERVAL_TIME >= B.START_DAY 
			AND A.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+2
			AND A.DBID = #{dbid}
			AND A.INSTANCE_NUMBER = #{inst_id}
			ORDER BY A.SNAP_ID
		), BASELINE_CPU AS
		(
			SELECT TO_CHAR(BEGIN_INTERVAL_TIME, 'HH24:MI') SNAP_TIME, ROUND(AVG(VAL1-BF_VAL1)/10000, 2) SYS_TIME
			FROM
			(
				SELECT A.STAT_NAME
					, C.BEGIN_INTERVAL_TIME
					, A.VALUE VAL1
					, LAG(VALUE) OVER(PARTITION BY C.STARTUP_TIME, A.STAT_NAME, TO_CHAR(C.BEGIN_INTERVAL_TIME, 'YYYY/MM/DD') ORDER BY C.BEGIN_INTERVAL_TIME) BF_VAL1
				FROM ODS_HIST_OSSTAT A, BASELINE_DAY B, SNAPSHOT_TIME C
				WHERE C.BEGIN_INTERVAL_TIME >= B.START_DAY 
				AND C.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+1
				AND A.SNAP_ID = C.SNAP_ID
				AND A.STAT_NAME = 'SYS_TIME'
				AND A.DBID = #{dbid}
				AND A.INSTANCE_NUMBER = #{inst_id}
				ORDER BY C.BEGIN_INTERVAL_TIME
			)
			GROUP BY TO_CHAR(BEGIN_INTERVAL_TIME, 'HH24:MI')
		), CURRENT_CPU AS
		(
			SELECT TO_CHAR(BEGIN_INTERVAL_TIME, 'HH24:MI') SNAP_TIME, ROUND((VAL1-BF_VAL1)/10000, 2) SYS_TIME
			FROM
			(
				SELECT A.STAT_NAME
					, C.BEGIN_INTERVAL_TIME
					, A.VALUE VAL1
					, LAG(VALUE) OVER(PARTITION BY C.STARTUP_TIME, A.STAT_NAME ORDER BY C.BEGIN_INTERVAL_TIME) BF_VAL1
				FROM ODS_HIST_OSSTAT A, BASELINE_DAY B, SNAPSHOT_TIME C
				WHERE C.BEGIN_INTERVAL_TIME >= B.END_DAY+1
				AND C.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD')+1
				AND A.SNAP_ID = C.SNAP_ID
				AND A.STAT_NAME = 'SYS_TIME' 
				AND A.DBID = #{dbid}
				AND A.INSTANCE_NUMBER = #{inst_id}
				ORDER BY C.BEGIN_INTERVAL_TIME
			)		
		)
		SELECT A.SNAP_TIME, A.SYS_TIME AS BASELINE_SYS_TIME, B.SYS_TIME AS CURRENT_SYS_TIME
		FROM BASELINE_CPU A, CURRENT_CPU B
		WHERE A.SNAP_TIME = B.SNAP_TIME
		AND A.SYS_TIME IS NOT NULL
		AND B.SYS_TIME IS NOT NULL
	</select>
	
	<select id="timeModelChartList_old_20190716" parameterType="cpuIncreaseUsage" resultType="cpuIncreaseUsage">
		/* PredictiveFailureAnalysisMapper.timeModelChartList */
		WITH DB_PREF AS
		(
			SELECT /*+ MATERIALIZE */
				BASELINE_DAY,
				LPAD(REGEXP_SUBSTR(BUSINESS_HOUR, '[^-]+', 1, 1), 2, '0')||'01' START_BUSINESS_HOUR,
				LPAD(REGEXP_SUBSTR(BUSINESS_HOUR, '[^-]+', 1, 2), 2, '0')||'00' END_BUSINESS_HOUR
			FROM
			(
				SELECT MAX(CASE WHEN A.PREF_ID = 21001 THEN TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) END) AS BASELINE_DAY,
					MAX(CASE WHEN A.PREF_ID = 21002 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) END) AS BUSINESS_HOUR
				FROM
				(
					SELECT /*+ LEADING(DB) */
						SP.PREF_ID, SP.DEFAULT_PREF_VALUE
					FROM SPOP_PREFERENCES SP
					WHERE PREF_ID IN (21001, 21002)
				) A,
				( SELECT PREF_ID, PREF_SEQ, PREF_VALUE
				    FROM (SELECT PREF_ID, PREF_SEQ, PREF_VALUE
				               , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
					          FROM DB_PREFERENCES B
					         WHERE DBID = #{dbid}
					           AND PREF_ID IN (21001, 21002)
					       )
					 WHERE PREF_SEQ = MAX_PREF_SEQ          
				) B
				WHERE A.PREF_ID = B.PREF_ID(+)
			)
		), BASELINE_DAY AS
		(
			SELECT MIN(DAY) START_DAY, MAX(DAY) END_DAY, COUNT(*) DAY_COUNT
			FROM
			(
				SELECT A.DAY, ROW_NUMBER() OVER(ORDER BY A.DAY DESC) RNUM
				FROM CALENDAR A
				WHERE A.DAY <![CDATA[ < ]]> TRUNC(TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD'))
			) A, DB_PREF B
			WHERE A.RNUM <![CDATA[ <= ]]> B.BASELINE_DAY
		), SNAPSHOT_TIME AS
		(
			SELECT A.SNAP_ID, 
				A.STARTUP_TIME,
				TRUNC(A.BEGIN_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS BEGIN_INTERVAL_TIME,
				TRUNC(A.END_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS END_INTERVAL_TIME
			FROM ODS_HIST_SNAPSHOT A, BASELINE_DAY B
			WHERE A.BEGIN_INTERVAL_TIME >= B.START_DAY 
			AND A.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+2
			AND A.DBID = #{dbid}
			AND A.INSTANCE_NUMBER = #{inst_id}
			ORDER BY A.SNAP_ID
		), BASELINE_TIME_MODEL AS
		(
			SELECT STAT_NAME
				, ROUND(SUM(CUR_VAL-BEFORE_VAL)/1000000/MAX(DAY_COUNT), 2) VALUE
			FROM
			(
				SELECT A.STAT_NAME
					, C.BEGIN_INTERVAL_TIME
					, A.VALUE CUR_VAL
					, LAG(A.VALUE) OVER(PARTITION BY A.INSTANCE_NUMBER, C.STARTUP_TIME, A.STAT_NAME ORDER BY C.BEGIN_INTERVAL_TIME) BEFORE_VAL
					, C.SNAP_ID
					, B.DAY_COUNT
				FROM ODS_HIST_SYS_TIME_MODEL A, BASELINE_DAY B, SNAPSHOT_TIME C, DB_PREF D
				WHERE C.BEGIN_INTERVAL_TIME >= B.START_DAY 
				AND C.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+1
				AND A.SNAP_ID = C.SNAP_ID
				AND A.DBID = #{dbid}
				AND A.INSTANCE_NUMBER = #{inst_id}
				AND A.STAT_NAME IN (
					'connection management call elapsed time',
					'sequence load elapsed time',
					'sql execute elapsed time',
					'parse time elapsed',
					'PL/SQL execution elapsed time',
					'inbound PL/SQL rpc elapsed time',
					'PL/SQL compilation elapsed time',
					'Java execution elapsed time'
				)
			ORDER BY C.BEGIN_INTERVAL_TIME
			)
			WHERE BEFORE_VAL IS NOT NULL
			GROUP BY STAT_NAME
		), CURRENT_TIME_MODEL AS
		(
			SELECT STAT_NAME
				, ROUND(SUM(CUR_VAL-BEFORE_VAL)/1000000, 2) VALUE
			FROM
			(
				SELECT A.STAT_NAME
					, C.BEGIN_INTERVAL_TIME
					, A.VALUE CUR_VAL
					, LAG(A.VALUE) OVER(PARTITION BY A.INSTANCE_NUMBER, C.STARTUP_TIME, A.STAT_NAME ORDER BY C.BEGIN_INTERVAL_TIME) BEFORE_VAL
					, C.SNAP_ID
				FROM ODS_HIST_SYS_TIME_MODEL A, BASELINE_DAY B, SNAPSHOT_TIME C
				WHERE C.BEGIN_INTERVAL_TIME >= B.END_DAY+1
				AND C.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD')+1
				AND A.SNAP_ID = C.SNAP_ID
				AND A.DBID = #{dbid}
				AND A.INSTANCE_NUMBER = #{inst_id}
				AND A.STAT_NAME IN (
					'connection management call elapsed time',
					'sequence load elapsed time',
					'sql execute elapsed time',
					'parse time elapsed',
					'PL/SQL execution elapsed time',
					'inbound PL/SQL rpc elapsed time',
					'PL/SQL compilation elapsed time',
					'Java execution elapsed time'
				)
				ORDER BY C.BEGIN_INTERVAL_TIME
			)
			WHERE BEFORE_VAL IS NOT NULL
			GROUP BY STAT_NAME
		)
		SELECT 
		    CASE
		        WHEN A.STAT_NAME = 'connection management call elapsed time' THEN 'CONNECTION MGMT' 
		        WHEN A.STAT_NAME = 'sequence load elapsed time' THEN 'SEQUENCE LOAD' 
		        WHEN A.STAT_NAME = 'sql execute elapsed time' THEN 'SQL EXECUTION' 
		        WHEN A.STAT_NAME = 'parse time elapsed' THEN 'PARSE' 
		        WHEN A.STAT_NAME = 'PL/SQL execution elapsed time' THEN 'PLSQL EXECUTION' 
		        WHEN A.STAT_NAME = 'inbound PL/SQL rpc elapsed time' THEN 'PLSQL RPC' 
		        WHEN A.STAT_NAME = 'PL/SQL compilation elapsed time' THEN 'PLSQL COMPILATION' 
		        WHEN A.STAT_NAME = 'Java execution elapsed time' THEN 'JAVA EXECUTION'
		    END AS STAT_NAME, A.VALUE AS BASELINE_TIME_MODEL, B.VALUE AS CURRENT_TIME_MODEL
		FROM BASELINE_TIME_MODEL A, CURRENT_TIME_MODEL B
		WHERE A.STAT_NAME = B.STAT_NAME
		ORDER BY CURRENT_TIME_MODEL DESC		
	</select>

	<select id="timeModelChartList" parameterType="cpuIncreaseUsage" resultType="cpuIncreaseUsage">
		/* PredictiveFailureAnalysisMapper.timeModelChartList */
		WITH DB_PREF AS
		(
			SELECT /*+ MATERIALIZE */
				BASELINE_DAY,
				LPAD(REGEXP_SUBSTR(BUSINESS_HOUR, '[^-]+', 1, 1), 2, '0')||'0000' START_BUSINESS_HOUR,
				LPAD(TO_NUMBER(REGEXP_SUBSTR(BUSINESS_HOUR, '[^-]+', 1, 2)) - 1, 2, '0')||'5959' END_BUSINESS_HOUR
			FROM
			(
				SELECT MAX(CASE WHEN A.PREF_ID = 21001 THEN TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) END) AS BASELINE_DAY,
					MAX(CASE WHEN A.PREF_ID = 21002 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) END) AS BUSINESS_HOUR
				FROM
				(
					SELECT /*+ LEADING(DB) */
						SP.PREF_ID, SP.DEFAULT_PREF_VALUE
					FROM SPOP_PREFERENCES SP
					WHERE PREF_ID IN (21001, 21002)
				) A,
				( SELECT PREF_ID, PREF_SEQ, PREF_VALUE
				    FROM (SELECT PREF_ID, PREF_SEQ, PREF_VALUE
				               , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
					          FROM DB_PREFERENCES B
					         WHERE DBID = #{dbid}
					           AND PREF_ID IN (21001, 21002)
					       )  
					 WHERE PREF_SEQ = MAX_PREF_SEQ        
				) B
				WHERE A.PREF_ID = B.PREF_ID(+)
			)
		), BASELINE_DAY AS
		(
			SELECT MIN(DAY) START_DAY, MAX(DAY) END_DAY, COUNT(*) DAY_COUNT
			FROM
			(
				SELECT A.DAY, ROW_NUMBER() OVER(ORDER BY A.DAY DESC) RNUM
				FROM CALENDAR A
				WHERE A.DAY <![CDATA[ < ]]> TRUNC(TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD'))
			) A, DB_PREF B
			WHERE A.RNUM <![CDATA[ <= ]]> B.BASELINE_DAY
		), SNAPSHOT_TIME AS
		(
			SELECT A.SNAP_ID, 
				A.STARTUP_TIME,
				TRUNC(A.BEGIN_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS BEGIN_INTERVAL_TIME,
				TRUNC(A.END_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS END_INTERVAL_TIME
			FROM ODS_HIST_SNAPSHOT A, BASELINE_DAY B
			WHERE A.BEGIN_INTERVAL_TIME >= B.START_DAY 
			AND A.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+2
			AND A.DBID = #{dbid}
			AND A.INSTANCE_NUMBER = #{inst_id}
			ORDER BY A.SNAP_ID
		), BASELINE_TIME_MODEL AS
		(
			SELECT STAT_NAME
				, ROUND(SUM(CUR_VAL-BEFORE_VAL)/1000000/MAX(DAY_COUNT), 2) VALUE
			FROM
			(
				SELECT A.STAT_NAME
					, C.BEGIN_INTERVAL_TIME
					, A.VALUE CUR_VAL
					, LAG(A.VALUE) OVER(PARTITION BY A.INSTANCE_NUMBER, C.STARTUP_TIME, A.STAT_NAME ORDER BY C.BEGIN_INTERVAL_TIME) BEFORE_VAL
					, C.SNAP_ID
					, B.DAY_COUNT
				FROM ODS_HIST_SYS_TIME_MODEL A, BASELINE_DAY B, SNAPSHOT_TIME C, DB_PREF D
				WHERE C.BEGIN_INTERVAL_TIME >= B.START_DAY 
				AND C.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+1
				AND A.SNAP_ID = C.SNAP_ID
				AND A.DBID = #{dbid}
				AND A.INSTANCE_NUMBER = #{inst_id}
				AND A.STAT_NAME IN (
					'connection management call elapsed time',
					'sequence load elapsed time',
					'sql execute elapsed time',
					'parse time elapsed',
					'PL/SQL execution elapsed time',
					'inbound PL/SQL rpc elapsed time',
					'PL/SQL compilation elapsed time',
					'Java execution elapsed time'
				)
			ORDER BY C.BEGIN_INTERVAL_TIME
			)
			WHERE BEFORE_VAL IS NOT NULL
			GROUP BY STAT_NAME
		), CURRENT_TIME_MODEL AS
		(
			SELECT STAT_NAME
				, ROUND(SUM(CUR_VAL-BEFORE_VAL)/1000000, 2) VALUE
			FROM
			(
				SELECT A.STAT_NAME
					, C.BEGIN_INTERVAL_TIME
					, A.VALUE CUR_VAL
					, LAG(A.VALUE) OVER(PARTITION BY A.INSTANCE_NUMBER, C.STARTUP_TIME, A.STAT_NAME ORDER BY C.BEGIN_INTERVAL_TIME) BEFORE_VAL
					, C.SNAP_ID
				FROM ODS_HIST_SYS_TIME_MODEL A, BASELINE_DAY B, SNAPSHOT_TIME C
				WHERE C.BEGIN_INTERVAL_TIME >= B.END_DAY+1
				AND C.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD')+1
				AND A.SNAP_ID = C.SNAP_ID
				AND A.DBID = #{dbid}
				AND A.INSTANCE_NUMBER = #{inst_id}
				AND A.STAT_NAME IN (
					'connection management call elapsed time',
					'sequence load elapsed time',
					'sql execute elapsed time',
					'parse time elapsed',
					'PL/SQL execution elapsed time',
					'inbound PL/SQL rpc elapsed time',
					'PL/SQL compilation elapsed time',
					'Java execution elapsed time'
				)
				ORDER BY C.BEGIN_INTERVAL_TIME
			)
			WHERE BEFORE_VAL IS NOT NULL
			GROUP BY STAT_NAME
		)
		SELECT 
		    CASE
		        WHEN A.STAT_NAME = 'connection management call elapsed time' THEN 'CONNECTION MGMT' 
		        WHEN A.STAT_NAME = 'sequence load elapsed time' THEN 'SEQUENCE LOAD' 
		        WHEN A.STAT_NAME = 'sql execute elapsed time' THEN 'SQL EXECUTION' 
		        WHEN A.STAT_NAME = 'parse time elapsed' THEN 'PARSE' 
		        WHEN A.STAT_NAME = 'PL/SQL execution elapsed time' THEN 'PLSQL EXECUTION' 
		        WHEN A.STAT_NAME = 'inbound PL/SQL rpc elapsed time' THEN 'PLSQL RPC' 
		        WHEN A.STAT_NAME = 'PL/SQL compilation elapsed time' THEN 'PLSQL COMPILATION' 
		        WHEN A.STAT_NAME = 'Java execution elapsed time' THEN 'JAVA EXECUTION'
		    END AS STAT_NAME, A.VALUE AS BASELINE_TIME_MODEL, B.VALUE AS CURRENT_TIME_MODEL
		FROM BASELINE_TIME_MODEL A, CURRENT_TIME_MODEL B
		WHERE A.STAT_NAME = B.STAT_NAME
		ORDER BY CURRENT_TIME_MODEL DESC		
	</select>	
	
	<select id="topSQLList" parameterType="cpuIncreaseUsage" resultType="cpuIncreaseUsage">
		/* PredictiveFailureAnalysisMapper.topSQLList */
		WITH BASELINE_DAY AS
		(
			SELECT MIN(DAY) START_DAY, MAX(DAY) END_DAY, COUNT(*) DAY_COUNT
			FROM
			(
				SELECT * 
				FROM CALENDAR
				WHERE DAY <![CDATA[ < ]]> TRUNC(TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD'))
				ORDER BY DAY DESC
			)
			WHERE ROWNUM <![CDATA[ <= ]]> 7
		), SNAPSHOT_TIME AS
		(
			SELECT A.SNAP_ID, 
				A.STARTUP_TIME,
				TRUNC(A.BEGIN_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.BEGIN_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS BEGIN_INTERVAL_TIME,
				TRUNC(A.END_INTERVAL_TIME, 'mi') -
				(
					CASE 
					WHEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) >= 5 THEN MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) - 10 
					ELSE MOD(EXTRACT(MINUTE FROM CAST(A.END_INTERVAL_TIME AS TIMESTAMP)), 10) 
					END
				) / (24 * 60) AS END_INTERVAL_TIME
			FROM ODS_HIST_SNAPSHOT A, BASELINE_DAY B
			WHERE A.BEGIN_INTERVAL_TIME >= B.START_DAY 
			AND A.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> B.END_DAY+2
			AND A.DBID = #{dbid}
			AND A.INSTANCE_NUMBER = #{inst_id}
			ORDER BY A.SNAP_ID
		)
		SELECT A.SQL_ID, A.CNT, A.ACTIVITY, B.SQL_TEXT
		FROM
		(
			SELECT A.DBID, A.SQL_ID, A.CNT, A.ACTIVITY
			FROM
			(
				SELECT DBID, SQL_ID, CNT, ACTIVITY, SUM(ACTIVITY) OVER(ORDER BY ACTIVITY DESC) CUME_ACTIVITY
				FROM
				(
					SELECT DBID,
						NVL(SQL_ID, 'NULL') SQL_ID, 
						COUNT(*) CNT,
						ROUND(100*COUNT(*)/ SUM(COUNT(1)) OVER(), 2) ACTIVITY
					FROM ODS_HIST_ATS_HISTORY A, BASELINE_DAY B, SNAPSHOT_TIME C
					WHERE C.BEGIN_INTERVAL_TIME >= B.END_DAY+1
					AND C.BEGIN_INTERVAL_TIME <![CDATA[ < ]]> TO_DATE(REPLACE(#{strStartDt},'-',''), 'YYYYMMDD')+1
					AND A.SNAP_ID = C.SNAP_ID
					AND SESSION_TYPE <![CDATA[ <> ]]> 'BACKGROUND'
					AND A.DBID = #{dbid}
					AND A.INSTANCE_NUMBER = #{inst_id}
					<choose>
						<when test="(strGubun != null and (strGubun eq '01'.toString()))"> <!-- CONNECTION MGMT -->
							AND IN_CONNECTION_MGMT = 'Y'
						</when>
						<when test="(strGubun != null and (strGubun eq '02'.toString()))"> <!-- SEQUENCE LOAD -->
							AND IN_SEQUENCE_LOAD = 'Y'
						</when>
						<when test="(strGubun != null and (strGubun eq '03'.toString()))"> <!-- SQL EXECUTION -->
							AND IN_SQL_EXECUTION = 'Y'
						</when>
						<when test="(strGubun != null and (strGubun eq '04'.toString()))"> <!-- PARSE -->
							AND IN_PARSE = 'Y'
						</when>
						<when test="(strGubun != null and (strGubun eq '05'.toString()))"> <!-- PLSQL EXECUTION -->
							AND IN_PLSQL_EXECUTION = 'Y'
						</when>
						<when test="(strGubun != null and (strGubun eq '06'.toString()))"> <!-- PLSQL RPC -->
							AND IN_PLSQL_RPC  = 'Y'
						</when>
						<when test="(strGubun != null and (strGubun eq '07'.toString()))"> <!-- PLSQL COMPILATION -->
							AND IN_PLSQL_COMPILATION = 'Y'
						</when>
						<when test="(strGubun != null and (strGubun eq '08'.toString()))"> <!-- JAVA EXECUTION -->
							AND IN_JAVA_EXECUTION = 'Y'
						</when>
					</choose>
					GROUP BY DBID, SQL_ID
					ORDER BY CNT DESC
				) A
			) A 
			WHERE A.ACTIVITY >= 50 OR A.CUME_ACTIVITY <![CDATA[ <= ]]> 50
		) A, ODS_HIST_SQLTEXT B
		WHERE A.DBID = B.DBID(+)
		AND A.SQL_ID = B.SQL_ID(+)	
	</select>
	
	<select id="cpuLimitPointPredictionList" parameterType="cpuLimitPrediction" resultType="cpuLimitPrediction">
		/* PredictiveFailureAnalysisMapper.cpuLimitPointPredictionList */
		WITH DB_PRIV AS
		(
			SELECT /*+ MATERIALIZE */
				UDP.DBID, DB.DB_NAME, I.INST_ID, I.INST_NM
			FROM USER_DB_PRIVILEGE UDP, USERS U, DATABASE DB, INSTANCE I
			WHERE UDP.USER_ID = U.USER_ID
			AND UDP.DBID = DB.DBID
			AND DB.DBID = I.DBID
			AND DB.USE_YN = 'Y'
			AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN UDP.PRIVILEGE_START_DAY AND UDP.PRIVILEGE_END_DAY
			AND U.USER_ID = #{user_id}
            AND DB.DB_OPERATE_TYPE_CD = (SELECT DEFAULT_PREF_VALUE 
                                          FROM SPOP_PREFERENCES 
                                         WHERE PREF_ID = '22001') 
		), DB_PREF AS
		(
			SELECT /*+ MATERIALIZE */
				A.DBID,
				TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) AS CPU_THRESHOLD
			FROM
			(
				SELECT /*+ LEADING(DB) */
					DB.DBID, SP.PREF_ID, SP.DEFAULT_PREF_VALUE
				FROM SPOP_PREFERENCES SP, (SELECT DISTINCT DBID FROM DB_PRIV) DB
				WHERE PREF_ID IN (21003)
			) A, 
			( SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
			    FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
			               , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
				          FROM DB_PREFERENCES B
				         WHERE PREF_ID IN (21003)
				        )
				 WHERE PREF_SEQ = MAX_PREF_SEQ         
			) B
			WHERE A.DBID = B.DBID(+)
			AND A.PREF_ID = B.PREF_ID(+)
		)
		SELECT B.DBID, 
			DB.DB_NAME,
			B.INST_ID,
			DB.INST_NM, 
			TO_CHAR(B.PREDICTION_DT, 'YYYY-MM-DD') AS PREDICTION_DATE,			
			BEFORE_3_MONTH_CPU_USAGE, 
			BEFORE_2_MONTH_CPU_USAGE, 
			BEFORE_1_MONTH_CPU_USAGE, 
			CURRENT_CPU_USAGE, 
			AFTER_1_MONTH_CPU_USAGE, 
			AFTER_2_MONTH_CPU_USAGE, 
			AFTER_3_MONTH_CPU_USAGE, 
			AFTER_6_MONTH_CPU_USAGE, 
			AFTER_12_MONTH_CPU_USAGE,
			TO_CHAR(B.PREDICTION_DT, 'YYYY/MM/DD HH24:MI:SS') AS PREDICTION_DT
		FROM
		(
			SELECT DBID, INST_ID, MAX(PREDICTION_DT) PREDICTION_DT
			FROM CPU_LIMIT_PREDICTION
			GROUP BY DBID, INST_ID
		) A, CPU_LIMIT_PREDICTION B, DB_PREF DP, DB_PRIV DB
		WHERE A.DBID = B.DBID
		AND A.INST_ID = B.INST_ID
		AND A.PREDICTION_DT = B.PREDICTION_DT
		AND A.DBID = DP.DBID
		AND B.DBID = DB.DBID
		AND B.INST_ID = DB.INST_ID
		<if test="dbid != null and dbid != ''">
			AND A.DBID=#{dbid}
		</if>
		<if test="inst_id != null and inst_id != ''">
			AND A.INST_ID=#{inst_id}
		</if>
		<choose>
			<when test="(predict_standard != null and (predict_standard eq '1'.toString()))"> <!-- 1개월 후 한계점 도달 -->
				AND AFTER_1_MONTH_CPU_USAGE >= DP.CPU_THRESHOLD
			</when>
			<when test="(predict_standard != null and (predict_standard eq '2'.toString()))"> <!-- 2개월 후 한계점 도달 -->
				AND AFTER_2_MONTH_CPU_USAGE >= DP.CPU_THRESHOLD
			</when>
			<when test="(predict_standard != null and (predict_standard eq '3'.toString()))"> <!-- 3개월 후 한계점 도달 -->
				AND AFTER_3_MONTH_CPU_USAGE >= DP.CPU_THRESHOLD
			</when>
			<when test="(predict_standard != null and (predict_standard eq '6'.toString()))"> <!-- 6개월 후 한계점 도달 -->
				AND AFTER_6_MONTH_CPU_USAGE >= DP.CPU_THRESHOLD
			</when>
			<when test="(predict_standard != null and (predict_standard eq '12'.toString()))"> <!-- 12개월 후 한계점 도달 -->
				AND AFTER_12_MONTH_CPU_USAGE >= DP.CPU_THRESHOLD
			</when>
		</choose>		
	</select>
	
	<select id="cpuLimitPredictionChartList" parameterType="cpuLimitPredictionDetail" resultType="cpuLimitPredictionDetail">
		/* PredictiveFailureAnalysisMapper.cpuLimitPredictionChartList */
		SELECT /*+ LEADING(TMP) FULL(TMP) USE_NL(A) */
			TO_CHAR(A.SNAP_DT, 'YYYYMMDD HH24:MI') SNAP_DT, 
			A.CPU_LIMIT, 
			A.CPU_USAGE, 
			A.PAST_CPU_USAGE_TREND, 
			A.FUTURE_CPU_USAGE_TREND
		FROM (SELECT DBID, INST_ID, PREDICTION_DT, SNAP_DT, ROW_NUMBER() OVER(PARTITION BY TRUNC(SNAP_DT) ORDER BY SNAP_DT) RNUM
				FROM CPU_LIMIT_PREDICTION_DETAIL
				WHERE DBID = #{dbid}
			) TMP
			, CPU_LIMIT_PREDICTION_DETAIL A
		WHERE TMP.DBID = A.DBID
		AND TMP.INST_ID = A.INST_ID
		AND TMP.PREDICTION_DT = A.PREDICTION_DT
		AND TMP.SNAP_DT = A.SNAP_DT
		AND TMP.RNUM = 1
		AND A.DBID = #{dbid}
		AND A.INST_ID = #{inst_id}
		AND A.PREDICTION_DT = TO_DATE(#{prediction_dt}, 'YYYY/MM/DD HH24:MI:SS')
		AND (A.PAST_CPU_USAGE_TREND > 0 OR A.FUTURE_CPU_USAGE_TREND > 0)
		AND (A.PAST_CPU_USAGE_TREND <![CDATA[ < ]]> 100 OR A.FUTURE_CPU_USAGE_TREND <![CDATA[ < ]]> 100)
		ORDER BY A.SNAP_DT
        </select>
        
        <select id="memoryLimitPointPredictionList" parameterType="memoryLimitPrediction" resultType="memoryLimitPrediction">
            /* PredictiveFailureAnalysisMapper.memoryLimitPointPredictionList */
            WITH DB_PRIV AS
            (
                SELECT /*+ MATERIALIZE */
                    UDP.DBID, DB.DB_NAME, I.INST_ID, I.INST_NM
                FROM USER_DB_PRIVILEGE UDP, USERS U, DATABASE DB, INSTANCE I
                WHERE UDP.USER_ID = U.USER_ID
                AND UDP.DBID = DB.DBID
                AND DB.DBID = I.DBID
                AND DB.USE_YN = 'Y'
                AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN UDP.PRIVILEGE_START_DAY AND UDP.PRIVILEGE_END_DAY
                AND U.USER_ID = #{user_id}
                AND DB.DB_OPERATE_TYPE_CD = (SELECT DEFAULT_PREF_VALUE 
                                              FROM SPOP_PREFERENCES 
                                             WHERE PREF_ID = '22001') 
            ), DB_PREF AS
            (
                SELECT /*+ MATERIALIZE */
                    A.DBID,
                    TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) AS MEM_THRESHOLD
                FROM
                (
                    SELECT /*+ LEADING(DB) */
                        DB.DBID, SP.PREF_ID, SP.DEFAULT_PREF_VALUE
                    FROM SPOP_PREFERENCES SP, (SELECT DISTINCT DBID FROM DB_PRIV) DB
                    WHERE PREF_ID IN (21014)
                ) A, 
                (   SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
                      FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
                                 , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
                              FROM DB_PREFERENCES B
                             WHERE PREF_ID IN (21014)
                            )
                     WHERE PREF_SEQ = MAX_PREF_SEQ        
                ) B
                WHERE A.DBID = B.DBID(+)
                AND A.PREF_ID = B.PREF_ID(+)
            )
            SELECT B.DBID, 
                DB.DB_NAME,
                B.INST_ID,
                DB.INST_NM, 
                TO_CHAR(B.PREDICTION_DT, 'YYYY-MM-DD') AS PREDICTION_DATE,  -- 예측기준일
                PHYSICAL_MEMORY_SIZE,        -- Physical Memory
                BEFORE_3_MONTH_MEM_USAGE,     -- 3개월전
                BEFORE_2_MONTH_MEM_USAGE,     -- 2개월전
                BEFORE_1_MONTH_MEM_USAGE,     -- 1개월전
                CURRENT_MEM_USAGE,           -- 현재
                AFTER_1_MONTH_MEM_USAGE,      -- 1개월후
                AFTER_2_MONTH_MEM_USAGE,      -- 2개월후
                AFTER_3_MONTH_MEM_USAGE,      -- 3개월후
                AFTER_6_MONTH_MEM_USAGE,      -- 6개월후
                AFTER_12_MONTH_MEM_USAGE,     -- 12개월후
                TO_CHAR(B.PREDICTION_DT, 'YYYY/MM/DD HH24:MI:SS') AS PREDICTION_DT
            FROM
            (
                SELECT DBID, INST_ID, MAX(PREDICTION_DT) PREDICTION_DT
                FROM MEMORY_LIMIT_PREDICTION
                GROUP BY DBID, INST_ID
            ) A, MEMORY_LIMIT_PREDICTION B, DB_PREF DP, DB_PRIV DB
            WHERE A.DBID = B.DBID
            AND A.INST_ID = B.INST_ID
            AND A.PREDICTION_DT = B.PREDICTION_DT
            AND A.DBID = DP.DBID
            AND B.DBID = DB.DBID
            AND B.INST_ID = DB.INST_ID
            
            <choose>
                <when test="(predict_standard != null and (predict_standard eq '1'.toString()))"> <!-- 1개월 후 한계점 도달 -->
                    AND AFTER_1_MONTH_MEM_USAGE >= (B.PHYSICAL_MEMORY_SIZE * DP.MEM_THRESHOLD) / 100
				ORDER BY AFTER_1_MONTH_MEM_USAGE
			</when>
			<when test="(predict_standard != null and (predict_standard eq '2'.toString()))"> <!-- 2개월 후 한계점 도달 -->
				AND AFTER_2_MONTH_MEM_USAGE >= (B.PHYSICAL_MEMORY_SIZE * DP.MEM_THRESHOLD) / 100
				ORDER BY AFTER_2_MONTH_MEM_USAGE
			</when>
			<when test="(predict_standard != null and (predict_standard eq '3'.toString()))"> <!-- 3개월 후 한계점 도달 -->
				AND AFTER_3_MONTH_MEM_USAGE >= (B.PHYSICAL_MEMORY_SIZE * DP.MEM_THRESHOLD) / 100
				ORDER BY AFTER_3_MONTH_MEM_USAGE
			</when>
			<when test="(predict_standard != null and (predict_standard eq '6'.toString()))"> <!-- 6개월 후 한계점 도달 -->
				AND AFTER_6_MONTH_MEM_USAGE >= (B.PHYSICAL_MEMORY_SIZE * DP.MEM_THRESHOLD) / 100
				ORDER BY AFTER_6_MONTH_MEM_USAGE
			</when>
			<when test="(predict_standard != null and (predict_standard eq '12'.toString()))"> <!-- 12개월 후 한계점 도달 -->
				AND AFTER_12_MONTH_MEM_USAGE >= (B.PHYSICAL_MEMORY_SIZE * DP.MEM_THRESHOLD) / 100
				ORDER BY AFTER_12_MONTH_MEM_USAGE
			</when>
		</choose>
	</select>
	
	<select id="memoryLimitPredictionChartList" parameterType="memoryLimitPredictionDetail" resultType="memoryLimitPredictionDetail">
		/* PredictiveFailureAnalysisMapper.memoryLimitPredictionDetail */
		WITH DB_PREF AS
		(
			SELECT /*+ MATERIALIZE */
				TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE))  AS MEMORY_THRESHOLD
			FROM (SELECT /*+ LEADING(DB) */
					SP.PREF_ID, SP.DEFAULT_PREF_VALUE
				FROM SPOP_PREFERENCES SP
				WHERE PREF_ID IN (21014)) A,
				(SELECT PREF_ID, PREF_SEQ, PREF_VALUE
				   FROM (SELECT PREF_ID, PREF_SEQ, PREF_VALUE
				              , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
				           FROM DB_PREFERENCES B
				          WHERE DBID = #{dbid}                                                            --> PARMETER
				            AND PREF_ID IN (21014)
				         )   
				  WHERE PREF_SEQ = MAX_PREF_SEQ       
         ) B
			WHERE A.PREF_ID = B.PREF_ID(+)
		)
		SELECT /*+ LEADING(TMP) USE_NL(A) */
			TO_CHAR(A.SNAP_DT, 'YYYYMMDD HH24:MI') SNAP_DT,
			B.PHYSICAL_MEMORY_SIZE, 
			ROUND(B.PHYSICAL_MEMORY_SIZE * DP.MEMORY_THRESHOLD / 100, 2) MEM_LIMIT, 
			A.MEM_USAGE, 
			A.PAST_MEM_USAGE_TREND, 
			A.FUTURE_MEM_USAGE_TREND
		FROM (SELECT DBID, INST_ID, PREDICTION_DT, SNAP_DT, ROW_NUMBER() OVER(PARTITION BY TRUNC(SNAP_DT) ORDER BY SNAP_DT) RNUM
				FROM MEMORY_LIMIT_PREDICTION_DETAIL A
				WHERE DBID = #{dbid}
				ORDER BY DBID, INST_ID, PREDICTION_DT, SNAP_DT
			) TMP
			, MEMORY_LIMIT_PREDICTION_DETAIL A, MEMORY_LIMIT_PREDICTION B, DB_PREF DP
		WHERE TMP.DBID = A.DBID
		AND TMP.INST_ID = A.INST_ID
		AND TMP.PREDICTION_DT = A.PREDICTION_DT
		AND TMP.SNAP_DT = A.SNAP_DT
		AND TMP.RNUM = 1
		AND A.DBID = B.DBID
		AND A.INST_ID = B.INST_ID
		AND A.PREDICTION_DT = B.PREDICTION_DT
		AND A.DBID = #{dbid}                                                                    --> PARMETER
		AND A.INST_ID = #{inst_id}                                                              --> PARMETER
		AND A.PREDICTION_DT = TO_DATE(#{prediction_dt}, 'YYYY/MM/DD HH24:MI:SS')           --> PARMETER
		AND (A.PAST_MEM_USAGE_TREND > 0 OR A.FUTURE_MEM_USAGE_TREND > 0)
		AND (A.PAST_MEM_USAGE_TREND   <![CDATA[ < ]]>   100 OR A.FUTURE_MEM_USAGE_TREND   <![CDATA[ < ]]>   100)
		ORDER BY A.SNAP_DT ASC
	</select>
	
	<!-- USER_ID	dbmanager -->
	<!-- DBID	3072386534 -->
	<!-- 1.SEQUENCE 사용한계점 도달 현황 -->
	<select id="sequenceLimitPointPredictionChartList" parameterType="sequenceLimitPoint" resultType="sequenceLimitPoint">
	/* PredictiveFailureAnalysisMapper.sequenceLimitPointPredictionChartList */
		WITH DB_PRIV AS  --로그인한 DBA가 담당하는 DB목록
		(
		    SELECT /*+ MATERIALIZE */
		           UDP.DBID, DB.DB_NAME
		    FROM USER_DB_PRIVILEGE UDP, USERS U, DATABASE DB
		    WHERE UDP.USER_ID = U.USER_ID
		    AND UDP.DBID = DB.DBID
		    AND DB.USE_YN = 'Y'
		    AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN UDP.PRIVILEGE_START_DAY AND UDP.PRIVILEGE_END_DAY
		    AND U.USER_ID = #{user_id} -- 로그인ID
            AND DB.DB_OPERATE_TYPE_CD = (SELECT DEFAULT_PREF_VALUE 
                                          FROM SPOP_PREFERENCES 
                                         WHERE PREF_ID = '22001') 
		)
		,DB_PREF AS /* SEQUENCE자원 한계값 기준정보 */
		(
		    SELECT /*+ MATERIALIZE */
		           A.DBID,
		           TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) AS SEQUENCE_THRESHOLD
		    FROM (SELECT /*+ LEADING(DB) */
		                 DB.DBID, SP.PREF_ID, SP.DEFAULT_PREF_VALUE
		          FROM SPOP_PREFERENCES SP, DB_PRIV DB
		          WHERE PREF_ID IN (21004)) A,
		         (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		            FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		                       , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
		                    FROM DB_PREFERENCES B
		                   WHERE PREF_ID IN (21004)
		                 )
		           WHERE PREF_SEQ = MAX_PREF_SEQ         
		         ) B
		     WHERE A.DBID = B.DBID(+)
		       AND A.PREF_ID = B.PREF_ID(+)
		)
		SELECT DB.DB_NAME,
		       B.DBID,
		       COUNT(*) CNT
		  FROM (SELECT DBID, MAX(PREDICTION_DT) PREDICTION_DT
		        FROM SEQ_LIMIT_PREDICTION
		        GROUP BY DBID) A,
		       SEQ_LIMIT_PREDICTION B,
		       DB_PREF DP,
		       DB_PRIV DB
		WHERE A.DBID = B.DBID
		AND A.PREDICTION_DT = B.PREDICTION_DT
		AND A.DBID = DP.DBID
		AND B.DBID = DB.DBID
		/****************** PARAMETER ***********************/
		<if test="selectValue eq 1">
			AND AFTER_1_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>
		<if test="selectValue eq 2">
			AND AFTER_2_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>
		<if test="selectValue eq 3">
			AND AFTER_3_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>
		<if test="selectValue eq 6">
			AND AFTER_6_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>
		<if test="selectValue eq 12">
			AND AFTER_12_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>
		/****************************************************/
		GROUP BY DB.DB_NAME,
		         B.DBID	
        ORDER BY CNT DESC
	</select>
	<!-- USER_ID	dbmanager -->
	<!-- DBID	3072386534 -->
	<!-- 2. DB별 SEQUENCE 사용한계점 도달 목록 -->
	<select id="sequenceLimitPointArrivalList" parameterType="sequenceLimitPoint" resultType="sequenceLimitPoint">
		/* PredictiveFailureAnalysisMapper.sequenceLimitPointArrivalList */
		WITH DB_PREF AS /* SEQUENCE자원 한계값 기준정보 */
		(
		    SELECT /*+ MATERIALIZE */
		           TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) AS SEQUENCE_THRESHOLD
		    FROM (SELECT /*+ LEADING(DB) */
		                 SP.PREF_ID, SP.DEFAULT_PREF_VALUE
		          FROM SPOP_PREFERENCES SP
		          WHERE PREF_ID IN (21004)) A,
		         (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		            FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		                       , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
		                    FROM DB_PREFERENCES B
		                   WHERE DBID = #{dbid}
		                     AND PREF_ID IN (21004)
		                 )    
		           WHERE PREF_SEQ = MAX_PREF_SEQ       
		         ) B
		     WHERE A.PREF_ID = B.PREF_ID(+)
		)
		SELECT TO_CHAR(B.PREDICTION_DT, 'YYYY/MM/DD') PREDICT_BASIC_DAY,/*"예측기준일"*/
		       B.SEQUENCE_OWNER,
		       B.SEQUENCE_NAME,
		       C.SEQUENCE_MAX_VALUE, 
		       B.BEFORE_3_MONTH_SEQUENCE_RATIO, /*"3개월전 SEQ사용율(%)"*/
		       B.BEFORE_2_MONTH_SEQUENCE_RATIO, /*"2개월전 SEQ사용율(%)"*/
		       B.BEFORE_1_MONTH_SEQUENCE_RATIO, /*"1개월전 SEQ사용율(%)"*/
		       B.CURRENT_SEQUENCE_RATIO, /*"현재 SEQ사용율(%)"*/
		       B.AFTER_1_MONTH_SEQUENCE_RATIO, /*"1개월후 SEQ사용율(%)"*/
		       B.AFTER_2_MONTH_SEQUENCE_RATIO, /*"2개월후 SEQ사용율(%)"*/
		       B.AFTER_3_MONTH_SEQUENCE_RATIO, /*"3개월후 SEQ사용율(%)"*/
		       B.AFTER_6_MONTH_SEQUENCE_RATIO, /*"6개월후 SEQ사용율(%)"*/
		       B.AFTER_12_MONTH_SEQUENCE_RATIO, /*"12개월후 SEQ사용율(%)"*/
		       B.PREDICTION_DT, 
		       B.DBID
		  FROM (SELECT MAX(PREDICTION_DT) PREDICTION_DT
		        FROM SEQ_LIMIT_PREDICTION
		        WHERE DBID = #{dbid}) A,
		       SEQ_LIMIT_PREDICTION B,
		       SEQ_LIMIT_PREDICTION_DETAIL C,
		       DB_PREF DP
		WHERE B.DBID = #{dbid}
		AND A.PREDICTION_DT = B.PREDICTION_DT
		AND B.PREDICTION_DT = C.PREDICTION_DT
		AND B.DBID = C.DBID
		AND B.SEQUENCE_OWNER = C.SEQUENCE_OWNER
		AND B.SEQUENCE_NAME = C.SEQUENCE_NAME
		AND C.BASE_DAY = (SELECT MAX(BASE_DAY) FROM SEQ_LIMIT_PREDICTION_DETAIL WHERE PREDICTION_DT = C.PREDICTION_DT AND DBID = C.DBID AND SEQUENCE_OWNER = C.SEQUENCE_OWNER AND SEQUENCE_NAME = C.SEQUENCE_NAME)
		/****************** PARAMETER ***********************/
		<if test="selectValue eq 1">
			AND AFTER_1_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
			ORDER BY AFTER_1_MONTH_SEQUENCE_RATIO DESC
		</if>
		<if test="selectValue eq 2">
			AND AFTER_2_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
			ORDER BY AFTER_2_MONTH_SEQUENCE_RATIO DESC
		</if>
		<if test="selectValue eq 3">
			AND AFTER_3_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
			ORDER BY AFTER_3_MONTH_SEQUENCE_RATIO DESC
		</if>
		<if test="selectValue eq 6">
			AND AFTER_6_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
			ORDER BY AFTER_6_MONTH_SEQUENCE_RATIO DESC
		</if>
		<if test="selectValue eq 12">
			AND AFTER_12_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
			ORDER BY AFTER_12_MONTH_SEQUENCE_RATIO DESC
		</if>		
		/****************************************************/
	</select>
	
	<select id="sequenceLimitPointArrivalMapList" parameterType="sequenceLimitPoint" resultType="map">
		/* PredictiveFailureAnalysisMapper.sequenceLimitPointArrivalMapList */
		WITH DB_PREF AS /* SEQUENCE자원 한계값 기준정보 */
		(
		    SELECT /*+ MATERIALIZE */
		           TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) AS SEQUENCE_THRESHOLD
		    FROM (SELECT /*+ LEADING(DB) */
		                 SP.PREF_ID, SP.DEFAULT_PREF_VALUE
		          FROM SPOP_PREFERENCES SP
		          WHERE PREF_ID IN (21004)) A,
		         (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		            FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		                       , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
		                    FROM DB_PREFERENCES B
		                   WHERE DBID = #{dbid}
		                     AND PREF_ID IN (21004)
		                 )
		           WHERE PREF_SEQ = MAX_PREF_SEQ          
		         ) B
		     WHERE A.PREF_ID = B.PREF_ID(+)
		)
		SELECT TO_CHAR(B.PREDICTION_DT, 'YYYY/MM/DD') "예측기준일",
		       B.SEQUENCE_OWNER "OWNER",
		       B.SEQUENCE_NAME "SEQUENCE_NAME",
		       C.SEQUENCE_MAX_VALUE AS "MAX VALUE", 
		       B.BEFORE_3_MONTH_SEQUENCE_RATIO AS "3개월전 SEQ사용율(%)", 
		       B.BEFORE_2_MONTH_SEQUENCE_RATIO AS "2개월전 SEQ사용율(%)", 
		       B.BEFORE_1_MONTH_SEQUENCE_RATIO AS "1개월전 SEQ사용율(%)", 
		       B.CURRENT_SEQUENCE_RATIO AS "현재 SEQ사용율(%)", 
		       B.AFTER_1_MONTH_SEQUENCE_RATIO AS "1개월후 SEQ사용율(%)", 
		       B.AFTER_2_MONTH_SEQUENCE_RATIO AS "2개월후 SEQ사용율(%)", 
		       B.AFTER_3_MONTH_SEQUENCE_RATIO AS "3개월후 SEQ사용율(%)", 
		       B.AFTER_6_MONTH_SEQUENCE_RATIO AS "6개월후 SEQ사용율(%)", 
		       B.AFTER_12_MONTH_SEQUENCE_RATIO AS "12개월후 SEQ사용율(%)" ,
		       B.PREDICTION_DT, 
		       B.DBID
		  FROM (SELECT MAX(PREDICTION_DT) PREDICTION_DT
		        FROM SEQ_LIMIT_PREDICTION
		        WHERE DBID = #{dbid}) A,
		       SEQ_LIMIT_PREDICTION B,
		       SEQ_LIMIT_PREDICTION_DETAIL C,
		       DB_PREF DP
		WHERE B.DBID = #{dbid}
		AND A.PREDICTION_DT = B.PREDICTION_DT
		AND B.PREDICTION_DT = C.PREDICTION_DT
		AND B.DBID = C.DBID
		AND B.SEQUENCE_OWNER = C.SEQUENCE_OWNER
		AND B.SEQUENCE_NAME = C.SEQUENCE_NAME
		AND C.BASE_DAY = (SELECT MAX(BASE_DAY) FROM SEQ_LIMIT_PREDICTION_DETAIL WHERE PREDICTION_DT = C.PREDICTION_DT AND DBID = C.DBID AND SEQUENCE_OWNER = C.SEQUENCE_OWNER AND SEQUENCE_NAME = C.SEQUENCE_NAME)
		/****************** PARAMETER ***********************/
		<if test="selectValue eq '1'">
			AND AFTER_1_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>
		<if test="selectValue eq '2'">
			AND AFTER_2_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>
		<if test="selectValue eq '3'">
			AND AFTER_3_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>
		<if test="selectValue eq '6'">
			AND AFTER_6_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>
		<if test="selectValue eq '12'">
			AND AFTER_12_MONTH_SEQUENCE_RATIO >= DP.SEQUENCE_THRESHOLD
		</if>		
		/****************************************************/
	</select>

	<!-- USER_ID	dbmanager -->
	<!-- DBID	3072386534 -->
	<!-- 3. SEQUENCE 한계점도달 상세 -->
	<select id="sequenceLimitPointPredictionDetailChartList" parameterType="sequenceLimitPoint" resultType="sequenceLimitPoint">
		/* PredictiveFailureAnalysisMapper.sequenceLimitPointPredictionDetailChartList */
		WITH DB_PREF AS /* SEQUENCE자원 한계값 기준정보 */
		(
		    SELECT /*+ MATERIALIZE */
		           TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) AS SEQUENCE_THRESHOLD_USAGE
		    FROM (SELECT /*+ LEADING(DB) */
		                 SP.PREF_ID, SP.DEFAULT_PREF_VALUE
		          FROM SPOP_PREFERENCES SP
		          WHERE PREF_ID IN (21004)) A,
		         (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		            FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		                       , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
		                    FROM DB_PREFERENCES B
		                   WHERE DBID = #{dbid}
		                     AND PREF_ID IN (21004)
		                 )
		           WHERE PREF_SEQ = MAX_PREF_SEQ           
		         ) B
		     WHERE A.PREF_ID = B.PREF_ID(+)
		)
		SELECT A.BASE_DAY SNAP_DT 
		       , A.SEQUENCE_MAX_VALUE SEQUENCE_MAX_VALUE
		       , A.SEQUENCE_THRESHOLD_VALUE SEQUENCE_THRESHOLD_VALUE
		       , A.SEQUENCE_LAST_NUMBER SEQUENCE_LAST_NUMBER
		       , A.PAST_SEQUENCE_VALUE_TREND PAST_SEQUENCE_VALUE_TREND
		       , A.FUTURE_SEQUENCE_VALUE_TREND FUTURE_SEQUENCE_VALUE_TREND
		       , B.SEQUENCE_THRESHOLD_USAGE SEQUENCE_THRESHOLD_USAGE
		       , A.SEQUENCE_LAST_NUMBER_USAGE SEQUENCE_LAST_NUMBER_USAGE
		       , A.PAST_SEQUENCE_USAGE_TREND PAST_SEQUENCE_USAGE_TREND
		       , A.FUTURE_SEQUENCE_USAGE_TREND FUTURE_SEQUENCE_USAGE_TREND
		FROM SEQ_LIMIT_PREDICTION_DETAIL A, DB_PREF B
		WHERE A.PREDICTION_DT = TO_DATE(#{prediction_dt}, 'YYYY/MM/DD HH24:MI:SS') --'2018/06/08 05:51:24'
		AND A.DBID = #{dbid} 
		AND A.SEQUENCE_OWNER = #{sequence_owner} -- 'JENNIFER'
		AND A.SEQUENCE_NAME = #{sequence_name} --'SQ_ERWIN_SNAP_ID'
		ORDER BY A.BASE_DAY
	</select>
	
	<!-- USER_ID	dbmanager -->
	<!-- DBID	3072386534 -->
	<!-- 1. TABLESPACE 사용한계점 도달 현황 -->
	<select id="tablespaceLimitPointPredictionChartList" parameterType="tablespaceLimitPoint" resultType="tablespaceLimitPoint">
		/* PredictiveFailureAnalysisMapper.tablespaceLimitPointPredictionChartList */
		WITH DB_PRIV AS  --로그인한 DBA가 담당하는 DB목록
		(
		    SELECT /*+ MATERIALIZE */
		           UDP.DBID, DB.DB_NAME
		    FROM USER_DB_PRIVILEGE UDP, USERS U, DATABASE DB
		    WHERE UDP.USER_ID = U.USER_ID
		    AND UDP.DBID = DB.DBID
		    AND DB.USE_YN = 'Y'
		    AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN UDP.PRIVILEGE_START_DAY AND UDP.PRIVILEGE_END_DAY
		    AND U.USER_ID = #{user_id} -- 로그인ID
            AND DB.DB_OPERATE_TYPE_CD = (SELECT DEFAULT_PREF_VALUE 
                                          FROM SPOP_PREFERENCES 
                                         WHERE PREF_ID = '22001') 
		)
		,DB_PREF AS /* SEQUENCE자원 한계값 기준정보 */
		(
		    SELECT /*+ MATERIALIZE */
		           A.DBID,
		           TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) AS TABLESPACE_THRESHOLD
		    FROM (SELECT /*+ LEADING(DB) */
		                 DB.DBID, SP.PREF_ID, SP.DEFAULT_PREF_VALUE
		          FROM SPOP_PREFERENCES SP, DB_PRIV DB
		          WHERE PREF_ID IN (21005)) A,
		         (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		            FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		                       , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
		                    FROM DB_PREFERENCES B
		                   WHERE PREF_ID IN (21005)
		                 )  
		           WHERE PREF_SEQ = MAX_PREF_SEQ      
		         ) B
		     WHERE A.DBID = B.DBID(+)
		       AND A.PREF_ID = B.PREF_ID(+)
		)
		SELECT DB.DB_NAME,
		       B.DBID,
		       COUNT(*) CNT
		  FROM (SELECT DBID, MAX(PREDICTION_DT) PREDICTION_DT
		        FROM TS_LIMIT_PREDICTION
		        GROUP BY DBID) A,
		       TS_LIMIT_PREDICTION B,
		       DB_PREF DP,
		       DB_PRIV DB
		WHERE A.DBID = B.DBID
		AND A.PREDICTION_DT = B.PREDICTION_DT
		AND A.DBID = DP.DBID
		AND B.DBID = DB.DBID
		/****************** PARAMETER ***********************/
		<if test="selectValue eq 1">
			AND AFTER_1_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
		</if>
		<if test="selectValue eq 2">
			AND AFTER_2_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
		</if>
		<if test="selectValue eq 3">
			AND AFTER_3_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
		</if>
		<if test="selectValue eq 6">
		AND AFTER_6_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
		</if>
		<if test="selectValue eq 12">
			AND AFTER_12_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
		</if>
		/****************************************************/
		GROUP BY DB.DB_NAME,
		         B.DBID
		ORDER BY CNT DESC
	</select>
		
	<!-- USER_ID	dbmanager -->
	<!-- DBID	3072386534 -->
	<!--  2. DB별 TABLESPACE 사용한계점 도달 목록 -->
	<select id="tablespaceLimitPointArrivalList" parameterType="tablespaceLimitPoint" resultType="tablespaceLimitPoint">
		/* PredictiveFailureAnalysisMapper.tablespaceLimitPointArrivalList */
		WITH DB_PREF AS /* TABLESPACE 자원 한계값 기준정보 */
		(
		    SELECT /*+ MATERIALIZE */
		           TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) AS TABLESPACE_THRESHOLD
		    FROM (SELECT /*+ LEADING(DB) */
		                 SP.PREF_ID, SP.DEFAULT_PREF_VALUE
		          FROM SPOP_PREFERENCES SP
		          WHERE PREF_ID IN (21005)) A,
		         (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		            FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
		                       , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
		                    FROM DB_PREFERENCES B
		                   WHERE DBID = #{dbid}
		                     AND PREF_ID IN (21005)
		                 )
		           WHERE PREF_SEQ = MAX_PREF_SEQ           
		         ) B
		     WHERE A.PREF_ID = B.PREF_ID(+)
		)
		SELECT TO_CHAR(B.PREDICTION_DT, 'YYYY/MM/DD') PREDICTION_DT,
		       B.TABLESPACE_NAME,
		       ROUND(C.TABLESPACE_SIZE/1024/1024, 2) AS TABLESPACE_SIZE, 
		       ROUND(B.CURRENT_TS_USED_SPACE/1024/1024, 2) AS CURRENT_TS_USED_SPACE,
		       ROUND(B.CURRENT_TS_USED_SPACE/1024/1024, 2) AS CURRENT_TS_USED_SPACE_B,
		       B.BEFORE_3_MONTH_TS_USED_PERCENT,
		       B.BEFORE_2_MONTH_TS_USED_PERCENT,
		       B.BEFORE_1_MONTH_TS_USED_PERCENT,
		       B.CURRENT_TS_USED_PERCENT,
		       B.AFTER_1_MONTH_TS_USED_PERCENT,
		       B.AFTER_2_MONTH_TS_USED_PERCENT,
		       B.AFTER_3_MONTH_TS_USED_PERCENT,
		       B.AFTER_6_MONTH_TS_USED_PERCENT,
		       B.AFTER_12_MONTH_TS_USED_PERCENT,
		       TO_CHAR(B.PREDICTION_DT,'YYYY/MM/DD HH24:MI:SS') PREDICTION_DATE, 
		       B.DBID
		  FROM (SELECT MAX(PREDICTION_DT) PREDICTION_DT
		        FROM TS_LIMIT_PREDICTION
		        WHERE DBID = #{dbid}) A,
		       TS_LIMIT_PREDICTION B,
		       TS_LIMIT_PREDICTION_DETAIL C,
		       DB_PREF DP
		WHERE B.DBID = #{dbid}
		AND A.PREDICTION_DT = B.PREDICTION_DT
		AND B.PREDICTION_DT = C.PREDICTION_DT
		AND B.DBID = C.DBID
		AND B.TABLESPACE_NAME = C.TABLESPACE_NAME
		AND C.BASE_DAY = (SELECT MAX(BASE_DAY) FROM TS_LIMIT_PREDICTION_DETAIL WHERE PREDICTION_DT = C.PREDICTION_DT AND DBID = C.DBID AND TABLESPACE_NAME = C.TABLESPACE_NAME)
		/****************** PARAMETER ***********************/
		<if test="selectValue eq 1">
			AND AFTER_1_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
			ORDER BY AFTER_1_MONTH_TS_USED_PERCENT DESC
		</if>
		<if test="selectValue eq 2">
			AND AFTER_2_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
			ORDER BY AFTER_2_MONTH_TS_USED_PERCENT DESC
		</if>
		<if test="selectValue eq 3">
			AND AFTER_3_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
			ORDER BY AFTER_3_MONTH_TS_USED_PERCENT DESC
		</if>
		<if test="selectValue eq 6">
			AND AFTER_6_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
			ORDER BY AFTER_6_MONTH_TS_USED_PERCENT DESC
		</if>
		<if test="selectValue eq 12">
			AND AFTER_12_MONTH_TS_USED_PERCENT >= DP.TABLESPACE_THRESHOLD
			ORDER BY AFTER_12_MONTH_TS_USED_PERCENT DESC
		</if>		
		/****************************************************/
	</select>
		
	<!-- USER_ID	dbmanager -->
	<!-- DBID	3072386534 -->
	<!-- PREDICTION_DT 20180618 -->
	<!-- TABLESPACE_NAME SYSAUX -->
	<!--  3. TABLESPACE 한계점도달 상세 -->
	<select id="tablespaceLimitPointPredictionDetailChartList" parameterType="tablespaceLimitPoint" resultType="tablespaceLimitPoint">
		/* PredictiveFailureAnalysisMapper.tablespaceLimitPointPredictionDetailChartList */
		WITH DB_PREF AS /* TABLESPACE 자원 한계값 기준정보 */
		(
			SELECT /*+ MATERIALIZE */
				TO_NUMBER(NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE)) AS TABLESPACE_THRESHOLD_USAGE
			FROM (SELECT /*+ LEADING(DB) */
					SP.PREF_ID, SP.DEFAULT_PREF_VALUE
				FROM SPOP_PREFERENCES SP
				WHERE PREF_ID IN (21005)) A,
				(SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
				   FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
				              , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
				           FROM DB_PREFERENCES B
				          WHERE DBID = #{dbid}
				            AND PREF_ID IN (21005)
				        )
				  WHERE PREF_SEQ = MAX_PREF_SEQ          
				) B
			WHERE A.PREF_ID = B.PREF_ID(+)
		)
		SELECT A.BASE_DAY SNAP_DT 
			, A.TABLESPACE_SIZE TABLESPACE_SIZE
			, ROUND(A.TABLESPACE_THRESHOLD_SIZE/1024/1024, 2) TABLESPACE_THRESHOLD_SIZE
			, ROUND(A.USED_SPACE/1024/1024, 2) USED_SPACE
			, ROUND(A.PAST_TS_USED_SPACE_TREND/1024/1024, 2) PAST_TS_USED_SPACE_TREND
			, ROUND(A.FUTURE_TS_USED_SPACE_TREND/1024/1024, 2) FUTURE_TS_USED_SPACE_TREND
			, B.TABLESPACE_THRESHOLD_USAGE TABLESPACE_THRESHOLD_USAGE
			, ROUND(A.USED_PERCENT, 2) USED_PERCENT
			, A.PAST_TS_USED_PERCENT_TREND PAST_TS_USED_PERCENT_TREND
			, A.FUTURE_TS_USED_PERCENT_TREND FUTURE_TS_USED_PERCENT_TREND
		FROM TS_LIMIT_PREDICTION_DETAIL A, DB_PREF B
		WHERE to_char(A.PREDICTION_DT,'YYYY/MM/DD') = #{prediction_dt}
		AND A.DBID = #{dbid} 
		AND A.TABLESPACE_NAME = #{tablespace_name} -- 'SYSAUX'
		ORDER BY A.BASE_DAY
	</select>
	
	<!-- start_first_exec_day 2018-03-12 -->
	<!-- end_first_exec_day 2019-03-18 -->
	<!-- except_yn N -->
	<!-- timeout_condition 1 -->
	<!-- 4.1 신규 APP 타임아웃 예측 APP 목록 -->
	<select id="newAppTimeoutPredictionList" parameterType="newAppTimeoutPrediction" resultType="newAppTimeoutPrediction">
		/* PredictiveFailureAnalysisMapper.newAppTimeoutPredictionList */
		WITH WRKJOB_PREF AS <!-- 신규 애플리케이션 타임아웃 예측 APP 목록 -->
		(
			SELECT A.WRKJOB_CD
				,MAX(CASE WHEN A.PREF_ID = 21006 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) ELSE '' END) AS APP_TIMEOUT_TIME    <!-- 애플리케이션 타임아웃 예측 임계값 -->
				,MAX(CASE WHEN A.PREF_ID = 21007 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) ELSE '' END) AS PREDICTION_BASE_DAY <!-- 신규 애플리케이션 타임아웃 예측 대상 선정 기준일 -->
				,MAX(CASE WHEN A.PREF_ID = 21008 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) ELSE '' END) AS EXEC_MIN_DAY        <!-- 신규 애플리케이션 타임아웃 예측 대상 선정 최소 발생일 수 -->
			FROM (SELECT A.WRKJOB_CD, B.PREF_ID, B.DEFAULT_PREF_VALUE
				FROM WRKJOB_CD A, SPOP_PREFERENCES B
				WHERE B.PREF_ID IN (21006, 21007, 21008)) A 
				,(SELECT WRKJOB_CD, PREF_ID, PREF_SEQ, PREF_VALUE, MAX(PREF_SEQ) OVER(PARTITION BY WRKJOB_CD, PREF_ID) MAX_PREF_SEQ
				FROM WRKJOB_PREFERENCES B
				WHERE PREF_ID IN (21006, 21007, 21008)) B
			WHERE A.WRKJOB_CD = B.WRKJOB_CD(+)
			AND A.PREF_ID = B.PREF_ID(+)
			AND B.PREF_SEQ(+) = B.MAX_PREF_SEQ(+)
			GROUP BY A.WRKJOB_CD
		)
		SELECT A.TR_CD, 
			A.EXCEPT_YN, 
			A.FIRST_EXEC_DAY, 
			A.LAST_EXEC_DAY, 
			A.EXEC_DAY_CNT, 
			A.EXEC_CNT, 
			A.LAST_PREDICTION_DAY,
			A.AFTER_1_WEEK_ELAPSED_TIME, 
			A.AFTER_2_WEEK_ELAPSED_TIME, 
			A.AFTER_3_WEEK_ELAPSED_TIME, 
			A.AFTER_1_MONTH_ELAPSED_TIME, 
			A.AFTER_2_MONTH_ELAPSED_TIME, 
			A.AFTER_3_MONTH_ELAPSED_TIME, 
			A.AFTER_6_MONTH_ELAPSED_TIME, 
			A.AFTER_12_MONTH_ELAPSED_TIME
		FROM NEW_APP_TO_PREDICTION A, WRKJOB_PREF B
		WHERE A.WRKJOB_CD = B.WRKJOB_CD
		AND A.PERF_PREDICTION_TARGET_YN = 'Y'
		
		<!-- 조회조건 -->
		AND A.WRKJOB_CD IN ( SELECT WRKJOB_CD
							FROM WRKJOB_CD
							<if test="wrkjob_cd != null">
								START WITH WRKJOB_CD = #{wrkjob_cd}
							</if>
							CONNECT BY PRIOR WRKJOB_CD = UPPER_WRKJOB_CD)  
							
		<if test="start_first_exec_day != null and end_first_exec_day != null">
			AND A.FIRST_EXEC_DAY BETWEEN #{start_first_exec_day}  AND #{end_first_exec_day}
		</if>
		
		<choose>
			<when test="except_yn != null and (except_yn eq 'Y'.toString())">
				AND A.EXCEPT_YN = 'Y' /* Y: 예외, N : 미예외, 전체 */
			</when>
			<when test="except_yn != null and (except_yn eq 'N'.toString())">
				AND A.EXCEPT_YN = 'N' /* Y: 예외, N : 미예외, 전체 */
			</when>
		</choose>
		
		<!-- 타임아웃조건 -->
		<choose>
			<when test="timeout_condition eq 1">
				AND A.AFTER_1_WEEK_ELAPSED_TIME >= B.APP_TIMEOUT_TIME     /* 1) 1주일후 */
				ORDER BY A.AFTER_1_WEEK_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 2">
				AND A.AFTER_2_WEEK_ELAPSED_TIME >= B.APP_TIMEOUT_TIME     /* 1) 2주일후 */
				ORDER BY A.AFTER_2_WEEK_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 3">
				AND A.AFTER_3_WEEK_ELAPSED_TIME >= B.APP_TIMEOUT_TIME     /* 1) 3주일후 */
				ORDER BY A.AFTER_3_WEEK_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 4">
				AND A.AFTER_1_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME    /* 1) 1개월후 */
				ORDER BY A.AFTER_1_MONTH_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 5">
				AND A.AFTER_2_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME    /* 1) 2개월후 */
				ORDER BY A.AFTER_2_MONTH_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 6">
				AND A.AFTER_3_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME    /* 1) 3개월후 */
				ORDER BY A.AFTER_3_MONTH_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 7">
				AND A.AFTER_6_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME    /* 1) 6개월후 */
				ORDER BY A.AFTER_6_MONTH_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 8">
				AND A.AFTER_12_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME   /* 1) 12개월후 */
				ORDER BY A.AFTER_12_MONTH_ELAPSED_TIME DESC
			</when>
		</choose>
	</select>
	
	<!-- wrkjob_cd 10000 -->
	<!-- tr_cd /pkg.kr.or.nhic.gg.i.c.Ggic320.ggic320_r5.do -->
	<!-- 4.2 신규 APP 타임아웃 예측 APP 챠트 -->
	<select id="newAppTimeoutPredictionChartList" parameterType="newAppTimeoutPrediction" resultType="newAppTimeoutPrediction">
		SELECT BASE_DAY, APP_TIMEOUT_LIMIT, AVG_ELAPSED_TIME, PAST_ELAPSED_TIME_TREND, FUTURE_ELAPSED_TIME_TREND
		FROM NEW_APP_TO_PRD_DETAIL
		<if test="wrkjob_cd != null">
			WHERE WRKJOB_CD = #{wrkjob_cd}
		</if>
		<if test="tr_cd != null">
			AND TR_CD = #{tr_cd}
		</if>
		ORDER BY BASE_DAY
	</select>
	
	<!-- wrkjob_cd 10000 -->
	<!-- tr_cd /pkg.kr.or.nhic.gg.i.c.Ggic320.ggic320_r5.do -->
	<!-- 4.3 신규 APP 타임아웃 예측 APP 챠트 -->
	<update id="newAppTimeoutPredictionExceptYnUpdate" parameterType="newAppTimeoutPredictionUpdate">
		UPDATE NEW_APP_TO_PREDICTION
		<if test="except_yn eq 'Y'.toString()">
			SET EXCEPT_YN = 'N'
		</if>
		<if test="except_yn eq 'N'.toString()">
			SET EXCEPT_YN = 'Y'
		</if>
		WHERE WRKJOB_CD = #{wrkjob_cd}
		AND TR_CD = #{tr_cd}
	</update>
	
	<!-- dbid 201718285 -->
	<!-- start_first_exec_day 2018-03-12 -->
	<!-- end_first_exec_day 2019-03-18 -->
	<!-- except_yn N -->
	<!-- timeout_condition 1 -->
	<!-- 5.1 신규 SQL 타임아웃 예측 SQL 목록 -->
	<select id="newSQLTimeoutPredictionList" parameterType="newSQLTimeoutPrediction" resultType="newSQLTimeoutPrediction">
		/* PredictiveFailureAnalysisMapper.newSQLTimeoutPredictionList */
		WITH PREF AS
		(
			SELECT A.DBID
				,MAX(CASE WHEN A.PREF_ID = 21010 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) ELSE '' END) AS APP_TIMEOUT_TIME    -- 애플리케이션 타임아웃 예측 임계값
				,MAX(CASE WHEN A.PREF_ID = 21011 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) ELSE '' END) AS PREDICTION_BASE_DAY -- 신규 애플리케이션 타임아웃 예측 대상 선정 기준일
				,MAX(CASE WHEN A.PREF_ID = 21012 THEN NVL(B.PREF_VALUE, A.DEFAULT_PREF_VALUE) ELSE '' END) AS EXEC_MIN_DAY        -- 신규 애플리케이션 타임아웃 예측 대상 선정 최소 발생일 수
			FROM (SELECT A.DBID, B.PREF_ID, B.DEFAULT_PREF_VALUE
				FROM DATABASE A, SPOP_PREFERENCES B
				WHERE B.PREF_ID IN (21010, 21011, 21012)) A 
				,(SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
				    FROM (SELECT DBID, PREF_ID, PREF_SEQ, PREF_VALUE
				               , MAX(PREF_SEQ) OVER(PARTITION BY DBID, PREF_ID) MAX_PREF_SEQ
    				        FROM DB_PREFERENCES B
				           WHERE PREF_ID IN (21010, 21011, 21012)
				         )
				   WHERE PREF_SEQ = MAX_PREF_SEQ        
				 ) B
			WHERE A.DBID = B.DBID(+)
			AND A.PREF_ID = B.PREF_ID(+)
			GROUP BY A.DBID
		)
		SELECT A.SQL_ID, 
			A.EXCEPT_YN, 
			A.FIRST_EXEC_DAY, 
			A.LAST_EXEC_DAY, 
			A.EXEC_DAY_CNT, 
			A.EXEC_CNT, 
			A.LAST_PREDICTION_DAY,
			A.AFTER_1_WEEK_ELAPSED_TIME, 
			A.AFTER_2_WEEK_ELAPSED_TIME, 
			A.AFTER_3_WEEK_ELAPSED_TIME, 
			A.AFTER_1_MONTH_ELAPSED_TIME, 
			A.AFTER_2_MONTH_ELAPSED_TIME, 
			A.AFTER_3_MONTH_ELAPSED_TIME, 
			A.AFTER_6_MONTH_ELAPSED_TIME, 
			A.AFTER_12_MONTH_ELAPSED_TIME,
			A.PLAN_HASH_VALUE
		FROM NEW_SQL_TO_PREDICTION A, PREF B
		WHERE A.DBID = B.DBID
		AND A.PERF_PREDICTION_TARGET_YN = 'Y'
		
		<!-- 조회조건 -->
		<if test="dbid != null">
			AND A.DBID = #{dbid} 
		</if>
		
		<if test="start_first_exec_day != null and end_first_exec_day != null">
			AND A.FIRST_EXEC_DAY BETWEEN #{start_first_exec_day}  AND #{end_first_exec_day}
		</if>
		
		<choose>
			<when test="except_yn != null and (except_yn eq 'Y'.toString())">
				AND A.EXCEPT_YN = 'Y' /* Y: 예외, N : 미예외, 전체 */
			</when>
			<when test="except_yn != null and (except_yn eq 'N'.toString())">
				AND A.EXCEPT_YN = 'N' /* Y: 예외, N : 미예외, 전체 */
			</when>
		</choose>

		<!-- 타임아웃조건 -->
		<choose>
			<when test="timeout_condition eq 1">
				AND A.AFTER_1_WEEK_ELAPSED_TIME >= B.APP_TIMEOUT_TIME     /* 1) 1주일후 */
				ORDER BY A.AFTER_1_WEEK_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 2">
				AND A.AFTER_2_WEEK_ELAPSED_TIME >= B.APP_TIMEOUT_TIME     /* 1) 2주일후 */
				ORDER BY A.AFTER_2_WEEK_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 3">
				AND A.AFTER_3_WEEK_ELAPSED_TIME >= B.APP_TIMEOUT_TIME     /* 1) 3주일후 */
				ORDER BY A.AFTER_3_WEEK_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 4">
				AND A.AFTER_1_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME    /* 1) 1개월후 */
				ORDER BY A.AFTER_1_MONTH_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 5">
				AND A.AFTER_2_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME    /* 1) 2개월후 */
				ORDER BY A.AFTER_2_MONTH_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 6">
				AND A.AFTER_3_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME    /* 1) 3개월후 */
				ORDER BY A.AFTER_3_MONTH_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 7">
				AND A.AFTER_6_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME    /* 1) 6개월후 */
				ORDER BY A.AFTER_6_MONTH_ELAPSED_TIME DESC
			</when>
			<when test="timeout_condition eq 8">
				AND A.AFTER_12_MONTH_ELAPSED_TIME >= B.APP_TIMEOUT_TIME   /* 1) 12개월후 */
				ORDER BY A.AFTER_12_MONTH_ELAPSED_TIME DESC
			</when>
		</choose>
	</select>
	
	<!-- wrkjob_cd 10000 -->
	<!-- tr_cd /pkg.kr.or.nhic.gg.i.c.Ggic320.ggic320_r5.do -->
	<!-- 5.2 신규 SQL 타임아웃 예측 APP 챠트 -->
	<select id="newSQLTimeoutPredictionChartList" parameterType="newSQLTimeoutPrediction" resultType="newSQLTimeoutPrediction">
		SELECT SNAP_DT, SQL_TIMEOUT_LIMIT, AVG_ELAPSED_TIME, PAST_ELAPSED_TIME_TREND, FUTURE_ELAPSED_TIME_TREND
		FROM NEW_SQL_TO_PRD_DETAIL
		<if test="dbid != null">
			WHERE DBID = #{dbid}
		</if>
		<if test="sql_id != null">
			AND SQL_ID = #{sql_id}
		</if>
		ORDER BY SNAP_DT
	</select>
	
	<update id="newSQLTimeoutPredictionExceptYnUpdate" parameterType="newSQLTimeoutPredictionUpdate">
		UPDATE NEW_SQL_TO_PREDICTION
		<if test="except_yn eq 'Y'.toString()">
			SET EXCEPT_YN = 'N'
		</if>
		<if test="except_yn eq 'N'.toString()">
			SET EXCEPT_YN = 'Y'
		</if>
		WHERE DBID = #{dbid}
		AND SQL_ID = #{sql_id}
	</update>
	
	<!-- wrkjob_cd 10000 -->
	<!-- tr_cd /pkg.kr.or.nhic.gg.i.c.Ggic320.ggic320_r5.do -->
	<!-- 6.1 CPU 사용률 챠트 -->
	<resultMap id="cpuUtilizationChartListMap" type="hashmap">
		<result property="begin_interval_time" column="BEGIN_INTERVAL_TIME" javaType="string" />
		<result property="cpu_usage" column="CPU_USAGE" javaType="java.math.BigDecimal" />
	</resultMap>
	<resultMap id="statDiffChartListMap" type="hashmap">
		<result property="snap_time" column="SNAP_TIME" javaType="string" />
		<result property="r_pgm_elapsed_time" column="R_PGM_ELAPSED_TIME" javaType="java.math.BigDecimal" />
		<result property="a_pgm_elapsed_time" column="A_PGM_ELAPSED_TIME" javaType="java.math.BigDecimal" />
		<result property="r_pgm_cpu_time" column="R_PGM_CPU_TIME" javaType="java.math.BigDecimal" />
		<result property="a_pgm_cpu_time" column="A_PGM_CPU_TIME" javaType="java.math.BigDecimal" />
		<result property="r_pgm_disk_reads" column="R_PGM_DISK_READS" javaType="java.lang.Long" />
		<result property="a_pgm_disk_reads" column="A_PGM_DISK_READS" javaType="java.lang.Long" />
		<result property="r_pgm_buffer_gets" column="R_PGM_BUFFER_GETS" javaType="java.lang.Long" />
		<result property="a_pgm_buffer_gets" column="A_PGM_BUFFER_GETS" javaType="java.lang.Long" />
		<result property="r_pgm_sorts" column="R_PGM_SORTS" javaType="java.lang.Long" />
		<result property="a_pgm_sorts" column="A_PGM_SORTS" javaType="java.lang.Long" />
		<result property="r_pgm_parse_calls" column="R_PGM_PARSE_CALLS" javaType="java.lang.Long" />
		<result property="a_pgm_parse_calls" column="A_PGM_PARSE_CALLS" javaType="java.lang.Long" />
	</resultMap>
	<resultMap id="adhocTopSQLListMap" type="hashmap">
		<result property="disk_reads" column="DISK_READS" javaType="java.lang.Long" />
		<result property="buffer_gets" column="BUFFER_GETS" javaType="java.lang.Long" />
		<result property="sql_id" column="SQL_ID" javaType="string" />
		<result property="parse_calls" column="PARSE_CALLS" javaType="java.lang.Long" />
		<result property="elapsed_time" column="ELAPSED_TIME" javaType="java.math.BigDecimal" />
		<result property="cpu_time" column="CPU_TIME" javaType="java.math.BigDecimal" />
		<result property="cpu_time_ratio" column="CPU_TIME_RATIO" javaType="java.math.BigDecimal" />
		<result property="rows_processed" column="ROWS_PROCESSED" javaType="java.lang.Long" />
	</resultMap>
	<resultMap id="adhocTopModuleListMap" type="hashmap">
		<result property="disk_reads" column="DISK_READS" javaType="java.lang.Long" />
		<result property="module" column="MODULE" javaType="string" />
		<result property="buffer_gets" column="BUFFER_GETS" javaType="java.lang.Long" />
		<result property="parse_calls" column="PARSE_CALLS" javaType="java.lang.Long" />
		<result property="elapsed_time" column="ELAPSED_TIME" javaType="java.math.BigDecimal" />
		<result property="cpu_time" column="CPU_TIME" javaType="java.math.BigDecimal" />
		<result property="cpu_time_ratio" column="CPU_TIME_RATIO" javaType="java.math.BigDecimal" />
		<result property="rows_processed" column="ROWS_PROCESSED" javaType="java.lang.Long" />
	</resultMap>
	<!-- <parameterMap id="paramId" type="hashmap">
		<parameter property="p_dbid" jdbcType="NUMERIC" javaType="java.lang.Long" />
		<parameter property="p_inst_id" jdbcType="NUMERIC" javaType="java.lang.Long" />
		<parameter property="p_anal_begin_dt" jdbcType="TIMESTAMP" javaType="java.util.Date" />
		<parameter property="p_anal_end_dt" jdbcType="TIMESTAMP" javaType="java.util.Date" />
	</parameterMap> -->
	<!-- <select id="unknownSQLFaultPredictionChartList" statementType="CALLABLE" parameterMap="paramId"> -->
	<select id="unknownSQLFaultPredictionChartList" statementType="CALLABLE">
		{ CALL SP_SPOP_UNKNOWN_SQL_STAT (
			<!-- 212205444,
			1,
			TO_DATE('2019/02/25 00:00:00', 'YYYY/MM/DD HH24:MI:SS'),
			TO_DATE('2019/03/25 23:59:59', 'YYYY/MM/DD HH24:MI:SS'),  -->
			#{p_dbid, mode=IN},
			#{p_inst_id, mode=IN},
			TO_DATE(#{p_anal_begin_dt, mode=IN} || ' 00:00:00', 'YYYY/MM/DD HH24:MI:SS'),
			TO_DATE(#{p_anal_end_dt, mode=IN} || ' 23:59:59', 'YYYY/MM/DD HH24:MI:SS'),
			#{p_cur_cpuusage, mode=OUT, jdbcType=CURSOR, javaType=java.sql.ResultSet,resultMap=cpuUtilizationChartListMap},
			#{p_cur_stat_diff, mode=OUT, jdbcType=CURSOR, javaType=java.sql.ResultSet,resultMap=statDiffChartListMap},
			#{p_cur_adhoc_top_sql, mode=OUT, jdbcType=CURSOR, javaType=java.sql.ResultSet,resultMap=adhocTopSQLListMap},
			#{p_cur_adhoc_top_module, mode=OUT, jdbcType=CURSOR, javaType=java.sql.ResultSet,resultMap=adhocTopModuleListMap}
		) }
	</select>
	
	<!-- 7 정규 SQL Parsing Schema Name 필터링 조건 -->
	
	<!-- dbid 1524008970 -->
	<!-- 7.1 Parsing Schema Name 콤보박스 조회 -->
	<select id="selectParsingSchemaNameComboBox" parameterType="regularSQLFilterCase" resultType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.selectParsingSchemaNameComboBox */
		SELECT USERNAME AS PARSING_SCHEMA_NAME,
			USER_ID
		FROM ODS_USERS
		<if test="dbid != null">
			WHERE DBID = #{dbid}
				AND BASE_DAY = (SELECT MAX(BASE_DAY) FROM ODS_USERS WHERE DBID = #{dbid})
				AND USERNAME NOT IN (SELECT USERNAME FROM UI_EXCEPT_DB_USER)
				AND USERNAME NOT IN (SELECT USER_ID FROM REGULAR_SQL_FILTER_USER WHERE DBID = #{dbid})
		</if>
	</select>
	
	<!-- dbid 1524008970 -->
	<!-- 7.2 정규 SQL Parsing Schema Name 필터링 조건 조회 -->
	<select id="selectRegularSQLParsingSchemaNameFilteringCase" parameterType="regularSQLFilterCase" resultType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.selectRegularSQLParsingSchemaNameFilteringCase */
		SELECT ROWNUM RNUM               -- NO
			, USER_ID AS USER_ID       -- Parsing Schema Name
			, DBID
		FROM (
			SELECT A.DBID AS DBID                                -- DBID
				, A.USER_ID AS USER_ID                           -- 사용자ID
			FROM REGULAR_SQL_FILTER_USER A                       -- 정규SQL대상사용자내역(TABLE)
			<if test="dbid != null">
				WHERE A.DBID = #{dbid}                           -- DBID
			</if>
			ORDER BY A.USER_ID
		)
	</select>

	<!-- 7.3회 기등록된 정규 SQL 대상 사용자 조회 -->
	<select id="checkPreRegisteredTargetUserCase" parameterType="regularSQLFilterCase" resultType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.checkPreRegisteredTargetUserCase */
		SELECT COUNT(*) RCOUNT
		FROM REGULAR_SQL_FILTER_USER A    -- 정규SQL대상필터조건내역(TABLE)
			<if test='dbid != null and user_id != null' >
				WHERE AND A.DBID = #{dbid}                                                  -- DBID
					AND A.USER_ID = #{user_id}
			</if>
	</select>
	
	<!-- dbid 1524008970 -->
	<!-- user_id dbmanager -->
	<!-- 7.4 정규 SQL 대상 사용자 추가 -->
	<insert id="insertRegularSQLTargetUser" parameterType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.insertRegularSQLTargetUser */
		INSERT INTO REGULAR_SQL_FILTER_USER                      -- 정규SQL대상사용자내역(TABLE)
			(DBID                                                -- DBID
			, USER_ID                                            -- 사용자ID
		) VALUES (#{dbid}                                        -- DBID
			, #{user_id}                                         -- 사용자ID
		)
	</insert>
	
	<!-- dbid 1524008970 -->
	<!-- user_id dbmanager -->
	<!-- 7.5 삭제 -->
	<delete id="deleteRegularSQLTargetUser" parameterType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.deleteRegularSQLTargetUser */
		DELETE REGULAR_SQL_FILTER_USER A                         -- 정규SQL대상사용자내역(TABLE)
		WHERE A.DBID = #{dbid}                                   -- DBID
			AND A.USER_ID = #{user_id}                           -- 사용자ID
	</delete>
	
	<!-- 8 정규 SQL 모듈 필터링 조건 -->
	
	<!-- 8.1 정규 SQL 모듈 필터링 콤보 조회 -->
	<select id="selectRegularSQLModuleFilterCombobox" resultType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.selectRegularSQLModuleFilterCombobox */
		SELECT CD_NM, CD
		FROM CD
		WHERE GRP_CD_ID = '1048'
	</select>
	
	<!-- dbid 1524008970 -->
	<!-- 8.2 기등록된 정규 SQL 모듈 필터링 조건 조회 -->
	<select id="selectRegularSQLModuleFilterCase" parameterType="regularSQLFilterCase" resultType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.selectRegularSQLModuleFilterCase */
		SELECT ROWNUM RNUM                      -- NO
			, REGULAR_SQL_FILTER_TYPE_NM      -- 필터유형
			, REGULAR_SQL_FILTER_CONDITION    -- 필터조건
			, DBID
			, REGULAR_SQL_FILTER_TYPE_CD
		FROM (
			SELECT A.DBID AS DBID                                                     -- DBID
					, A.REGULAR_SQL_FILTER_TYPE_CD AS REGULAR_SQL_FILTER_TYPE_CD      -- 정규SQL필터유형코드
					, CD1.CD_NM AS REGULAR_SQL_FILTER_TYPE_NM                         -- 정규SQL필터유형명
					, A.REGULAR_SQL_FILTER_CONDITION AS REGULAR_SQL_FILTER_CONDITION  -- 정규SQL필터조건내용
			FROM REGULAR_SQL_FILTER_CONDITION A                                       -- 정규SQL대상필터조건내역(TABLE)
				, CD CD1
			WHERE A.REGULAR_SQL_FILTER_TYPE_CD = CD1.CD
				AND CD1.GRP_CD_ID = '1048'
				<if test="dbid != null">
					AND A.DBID = #{dbid}                                              -- DBID
				</if>
			ORDER BY A.REGULAR_SQL_FILTER_TYPE_CD, A.REGULAR_SQL_FILTER_CONDITION
		)
	</select>
	
	<!-- 
		2) 추가 
		- 추가하기전에 기 등록된 필터링조건이 있는제 체크
		- 기 등록된 필터링조건이 있으면 "필터링조건이 이미등록되었습니다." 메시지 출력
		- 기 등록되지 않은 필터링 조건이면 저장
	 -->
	 
	<!-- dbid 1524008970 -->
	<!-- 8.3 기등록된 필터링 조건 체크 -->
	<select id="checkRegisteredRegularSQLModuleFilterCase" parameterType="regularSQLFilterCase" resultType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.checkPreRegisteredRegularSQLModuleFilterCase */
		SELECT COUNT(*) RCOUNT
		FROM REGULAR_SQL_FILTER_CONDITION A    -- 정규SQL대상필터조건내역(TABLE)
		<if test="dbid != null">
			WHERE A.DBID = #{dbid}                                                  -- DBID
		</if>
		<if test="regular_sql_filter_type_cd != null and regular_sql_filter_type_cd != ''">
			AND  A.REGULAR_SQL_FILTER_TYPE_CD = #{regular_sql_filter_type_cd}     -- 정규SQL필터유형코드
		</if>
		<if test="regular_sql_filter_condition != null and regular_sql_filter_condition != ''">
			AND  A.REGULAR_SQL_FILTER_CONDITION = #{regular_sql_filter_condition} -- 정규SQL필터조건내용
		</if>
	</select>
	
	<!-- dbid 1524008970 -->
	<!-- user_id dbmanager -->
	<!-- 8.4 기 등록되지 않은 필터링 조건이면 저장 -->
	<insert id="insertRegularSQLModuleFilterCase" parameterType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.insertRegularSQLModuleFilterCase */
		INSERT INTO REGULAR_SQL_FILTER_CONDITION                        -- 정규SQL대상필터조건내역(TABLE)
			( DBID                                                      -- DBID
			, REGULAR_SQL_FILTER_TYPE_CD                                -- 정규SQL필터유형코드
			, REGULAR_SQL_FILTER_CONDITION                              -- 정규SQL필터조건내용
		) VALUES ( #{dbid}                                              -- DBID
			, #{regular_sql_filter_type_cd}                             -- 정규SQL필터유형코드
			, #{regular_sql_filter_condition}                           -- 정규SQL필터조건내용
		) 
	</insert>
	
	<!-- dbid 1524008970 -->
	<!-- user_id dbmanager -->
	<!-- 8.5 삭제 -->
	<delete id="deleteRegularSQLModuleFilterCase" parameterType="regularSQLFilterCase">
		/* PredictiveFailureAnalysisMapper.deleteRegularSQLModuleFilterCase */
		DELETE REGULAR_SQL_FILTER_CONDITION A                                    -- 정규SQL대상필터조건내역(TABLE)
		WHERE A.DBID = #{dbid}                                                   -- DBID
			AND A.REGULAR_SQL_FILTER_TYPE_CD = #{regular_sql_filter_type_cd}     -- 정규SQL필터유형코드
			AND A.REGULAR_SQL_FILTER_CONDITION = #{regular_sql_filter_condition} -- 정규SQL필터조건내용
	</delete>
	
</mapper>